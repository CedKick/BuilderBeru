<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Manaya Raid - Test Client</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0f0f1a; color: #e2e8f0; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
    #app { display: flex; height: 100vh; }
    #sidebar { width: 320px; padding: 10px; background: #1a1a2e; overflow-y: auto; flex-shrink: 0; border-right: 1px solid #2a2a4e; }
    #game { flex: 1; position: relative; }
    canvas { display: block; cursor: crosshair; }

    h2 { color: #a78bfa; margin-bottom: 6px; font-size: 15px; }
    h3 { color: #7c3aed; margin: 6px 0 3px; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; }
    button {
      background: #7c3aed; color: white; border: none; padding: 5px 12px;
      border-radius: 5px; cursor: pointer; margin: 2px; font-size: 11px; transition: background 0.15s;
    }
    button:hover { background: #6d28d9; }
    button:disabled { background: #4a4a5e; cursor: not-allowed; }
    button.danger { background: #ef4444; }
    button.success { background: #10b981; }
    input, select {
      background: #2a2a3e; color: #e2e8f0; border: 1px solid #4a4a5e;
      padding: 4px 7px; border-radius: 4px; margin: 2px; font-size: 11px; width: calc(100% - 4px);
    }
    label { font-size: 10px; color: #888; display: block; margin-top: 3px; }
    .inline-row { display: flex; gap: 4px; align-items: center; }
    .inline-row > * { flex: 1; }

    #log {
      height: 120px; overflow-y: auto; background: #0a0a15; padding: 5px;
      border-radius: 4px; font-size: 9px; font-family: monospace; margin-top: 4px;
    }
    .log-entry { margin: 1px 0; line-height: 1.2; }
    .log-entry.event { color: #a78bfa; }
    .log-entry.error { color: #ef4444; }
    .log-entry.info { color: #38bdf8; }
    .log-entry.damage { color: #f97316; }
    .log-entry.heal { color: #10b981; }
    .log-entry.hunter { color: #c084fc; }

    #status { padding: 5px 7px; background: #2a2a3e; border-radius: 4px; margin-bottom: 4px; font-size: 10px; }
    .room-players { font-size: 10px; color: #ccc; margin: 3px 0; }
    .room-players .ready { color: #10b981; }
    .room-players .not-ready { color: #888; }

    /* ‚îÄ‚îÄ Boss HP Bar ‚îÄ‚îÄ */
    .boss-hud {
      position: absolute; top: 8px; left: 50%; transform: translateX(-50%);
      width: 600px; pointer-events: none; z-index: 10;
    }
    .boss-hud-name { text-align: center; font-weight: bold; font-size: 16px; text-shadow: 0 0 12px rgba(239,68,68,0.6); margin-bottom: 2px; }
    .boss-bar-outer { position: relative; height: 30px; background: #111; border-radius: 5px; border: 2px solid #444; overflow: hidden; }
    .boss-bar-bg { position: absolute; top: 0; left: 0; right: 0; bottom: 0; opacity: 0.3; }
    .boss-bar-fill { position: absolute; top: 0; left: 0; bottom: 0; transition: width 0.08s linear; border-radius: 3px; }
    .boss-bar-text { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 13px; color: #fff; font-weight: bold; text-shadow: 0 0 4px #000; }
    .boss-bar-info { text-align: center; color: #aaa; font-size: 11px; margin-top: 2px; }
    .boss-shield-bar { height: 8px; background: #111; border-radius: 4px; margin-top: 2px; overflow: hidden; display: none; }
    .boss-shield-fill { height: 100%; background: linear-gradient(90deg, #38bdf8, #818cf8); transition: width 0.1s; }
    .boss-rage-info { text-align: center; font-size: 11px; margin-top: 1px; }

    /* ‚îÄ‚îÄ Player HP/Mana (BOTTOM of screen) ‚îÄ‚îÄ */
    .player-hud {
      position: absolute; bottom: 140px; left: 50%; transform: translateX(-50%);
      width: 420px; pointer-events: none; z-index: 10;
    }
    .player-hud-name { text-align: center; font-size: 11px; color: #ccc; margin-bottom: 2px; }
    .player-hp-outer { position: relative; height: 22px; background: #1a1a1a; border-radius: 4px; border: 1px solid #333; overflow: hidden; margin-bottom: 3px; }
    .player-hp-fill { position: absolute; top: 0; left: 0; bottom: 0; transition: width 0.1s; border-radius: 3px; }
    .player-hp-text { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 12px; color: #fff; font-weight: bold; text-shadow: 0 0 3px #000; }
    .player-mana-outer { position: relative; height: 10px; background: #1a1a1a; border-radius: 3px; border: 1px solid #222; overflow: hidden; }
    .player-mana-fill { position: absolute; top: 0; left: 0; bottom: 0; background: #3b82f6; transition: width 0.1s; border-radius: 2px; }
    .player-mana-text { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 8px; color: #ccc; }
    .player-endurance-outer { position: relative; height: 10px; background: #1a1a1a; border-radius: 3px; border: 1px solid #222; overflow: hidden; margin-top: 2px; display: none; }
    .player-endurance-fill { position: absolute; top: 0; left: 0; bottom: 0; background: linear-gradient(90deg, #f59e0b, #eab308); transition: width 0.1s; border-radius: 2px; }
    .player-endurance-text { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 8px; color: #fff; font-weight: bold; text-shadow: 0 0 2px #000; }

    /* ‚îÄ‚îÄ Skill Bar (bigger) ‚îÄ‚îÄ */
    .skill-bar {
      position: absolute; bottom: 14px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 5px; z-index: 10; pointer-events: none;
    }
    .skill-slot {
      width: 62px; height: 62px; background: rgba(0,0,0,0.8);
      border: 2px solid #444; border-radius: 8px; position: relative;
      display: flex; align-items: center; justify-content: center; flex-direction: column;
    }
    .skill-slot.ready { border-color: #eab308; box-shadow: 0 0 10px rgba(234,179,8,0.5); background: rgba(234,179,8,0.08); }
    .skill-slot.no-mana { border-color: #555; opacity: 0.5; }
    .skill-slot.active { border-color: #a78bfa; box-shadow: 0 0 10px rgba(167,139,250,0.5); }
    .skill-slot .key-label { position: absolute; top: 2px; left: 4px; font-size: 11px; color: #aaa; font-weight: bold; }
    .skill-slot .skill-name { font-size: 8px; color: #bbb; text-align: center; margin-top: 10px; line-height: 1.1; }
    .skill-slot .cd-overlay { position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.7); transition: height 0.05s linear; border-radius: 0 0 6px 6px; }
    .skill-slot .cd-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); font-size: 18px; color: #fff; font-weight: bold; text-shadow: 0 0 5px #000; }
    .skill-sep { width: 2px; height: 62px; background: #333; border-radius: 1px; }

    /* ‚îÄ‚îÄ Hunter Slots ‚îÄ‚îÄ */
    .hunter-bar {
      position: absolute; bottom: 84px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 6px; z-index: 10; pointer-events: none;
    }
    .hunter-slot {
      width: 48px; height: 48px; background: rgba(0,0,0,0.8);
      border: 2px solid #7c3aed; border-radius: 50%; position: relative;
      display: flex; align-items: center; justify-content: center; flex-direction: column;
    }
    .hunter-slot.on-cd { border-color: #555; opacity: 0.6; }
    .hunter-slot .h-key { position: absolute; top: -9px; left: 50%; transform: translateX(-50%); font-size: 11px; color: #a78bfa; font-weight: bold; background: #1a1a2e; padding: 0 4px; border-radius: 3px; }
    .hunter-slot .h-name { font-size: 7px; color: #ccc; text-align: center; }
    .hunter-slot .h-cd { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); font-size: 15px; color: #fff; font-weight: bold; text-shadow: 0 0 5px #000; }

    /* ‚îÄ‚îÄ DPS Meter (bigger) ‚îÄ‚îÄ */
    .dps-panel {
      position: absolute; top: 90px; right: 10px; width: 230px;
      background: rgba(0,0,0,0.75); border-radius: 8px; padding: 8px 10px;
      z-index: 10; pointer-events: none; border: 1px solid #333;
    }
    .dps-title { font-size: 12px; color: #999; text-transform: uppercase; margin-bottom: 4px; letter-spacing: 1px; }
    .dps-row { display: flex; align-items: center; gap: 5px; margin: 3px 0; font-size: 12px; }
    .dps-color { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
    .dps-name { flex: 1; color: #ddd; white-space: nowrap; overflow: hidden; }
    .dps-val { color: #fff; font-weight: bold; font-family: monospace; flex-shrink: 0; font-size: 13px; }
    .dps-bar-bg { flex: 2; height: 8px; background: #222; border-radius: 4px; overflow: hidden; }
    .dps-bar-fill { height: 100%; border-radius: 4px; transition: width 0.2s; }

    /* ‚îÄ‚îÄ Buff/Debuff ‚îÄ‚îÄ */
    .buff-display {
      position: absolute; bottom: 198px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 4px; z-index: 10; pointer-events: none;
    }
    .buff-icon {
      width: 32px; height: 32px; background: rgba(0,0,0,0.75);
      border-radius: 5px; display: flex; align-items: center; justify-content: center;
      font-size: 14px; position: relative;
    }
    .buff-icon.positive { border: 2px solid #10b981; }
    .buff-icon.negative { border: 2px solid #ef4444; }
    .buff-icon .buff-dur { position: absolute; bottom: -3px; right: -3px; font-size: 9px; color: #fff; background: #333; border-radius: 2px; padding: 0 3px; }
    .buff-icon .buff-stacks { position: absolute; top: -3px; right: -3px; font-size: 9px; color: #fff; background: #7c3aed; border-radius: 50%; width: 14px; height: 14px; display: flex; align-items: center; justify-content: center; }

    @keyframes pulse { 0%,100% { transform: scale(1); } 50% { transform: scale(1.15); } }

    /* ‚îÄ‚îÄ Party HUD (left side, vertically centered) ‚îÄ‚îÄ */
    .party-hud {
      position: absolute; top: 50%; left: 10px; transform: translateY(-50%); z-index: 10; pointer-events: none;
      display: flex; flex-direction: column; gap: 4px; min-width: 200px;
    }
    .party-member {
      display: flex; align-items: center; gap: 6px; padding: 4px 8px;
      background: rgba(0,0,0,0.7); border-radius: 6px; border: 1px solid #333;
    }
    .party-member.dead { opacity: 0.4; }
    .party-member.is-me { border-color: #a78bfa; }
    .party-member .pm-class-icon { font-size: 14px; flex-shrink: 0; }
    .party-member .pm-info { flex: 1; min-width: 0; }
    .party-member .pm-name { font-size: 9px; color: #ccc; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .party-member .pm-hp-outer { height: 10px; background: #1a1a1a; border-radius: 3px; overflow: hidden; margin-top: 2px; position: relative; }
    .party-member .pm-hp-fill { height: 100%; border-radius: 2px; transition: width 0.1s; }
    .party-member .pm-hp-text { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 7px; color: #fff; font-weight: bold; text-shadow: 0 0 2px #000; }
    .party-member .pm-mana-outer { height: 4px; background: #1a1a1a; border-radius: 2px; overflow: hidden; margin-top: 1px; }
    .party-member .pm-mana-fill { height: 100%; background: #3b82f6; border-radius: 2px; transition: width 0.1s; }
    .party-member .pm-buffs { display: flex; gap: 2px; margin-top: 2px; flex-wrap: wrap; }
    .party-member .pm-buff { width: 14px; height: 14px; border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 8px; }
    .party-member .pm-buff.pos { background: rgba(16,185,129,0.3); border: 1px solid #10b981; }
    .party-member .pm-buff.neg { background: rgba(239,68,68,0.3); border: 1px solid #ef4444; }

    /* ‚îÄ‚îÄ Timer ‚îÄ‚îÄ */
    .game-timer { position: absolute; top: 12px; right: 14px; z-index: 10; font-size: 24px; font-weight: bold; pointer-events: none; text-shadow: 0 0 8px #000; }

    /* ‚îÄ‚îÄ Simulation Panel ‚îÄ‚îÄ */
    .sim-panel { background: #1a1a2e; border: 2px solid #f59e0b; border-radius: 6px; padding: 6px; margin-top: 6px; }
    .sim-panel h3 { color: #f59e0b; }
    .sim-panel button { font-size: 10px; padding: 3px 8px; background: #b45309; }
    .sim-panel button:hover { background: #d97706; }
    .sim-toggle { display: flex; align-items: center; gap: 6px; margin-bottom: 4px; }
    .sim-toggle input[type="checkbox"] { accent-color: #f59e0b; }
    .sim-toggle label { font-size: 11px; color: #f59e0b; cursor: pointer; margin: 0; }

    /* ‚îÄ‚îÄ Controls ‚îÄ‚îÄ */
    .controls-info { font-size: 9px; color: #555; margin-top: 4px; line-height: 1.4; }
    .controls-info kbd { background: #333; padding: 1px 3px; border-radius: 2px; font-size: 8px; border: 1px solid #555; }

    /* ‚îÄ‚îÄ Death ‚îÄ‚îÄ */
    @keyframes deathPulse { 0%,100% { opacity: 0.7; transform: translate(-50%,-50%) scale(1); } 50% { opacity: 1; transform: translate(-50%,-50%) scale(1.05); } }
    #game.dead-filter canvas { filter: grayscale(70%) brightness(0.6); transition: filter 0.5s; }
    #game.dead-filter .player-hud { opacity: 0.3; }
    #game.dead-filter .skill-bar { opacity: 0.2; }

    /* ‚îÄ‚îÄ Game End Overlay ‚îÄ‚îÄ */
    @keyframes gameEndSlideIn { from { opacity: 0; transform: translate(-50%,-50%) scale(0.8); } to { opacity: 1; transform: translate(-50%,-50%) scale(1); } }
    @keyframes xpBarFill { from { width: 0; } }
    @keyframes victoryGlow { 0%,100% { text-shadow: 0 0 20px #10b981, 0 0 40px #10b981; } 50% { text-shadow: 0 0 40px #10b981, 0 0 80px #10b981, 0 0 120px #059669; } }
    @keyframes defeatGlow { 0%,100% { text-shadow: 0 0 20px #ef4444, 0 0 40px #ef4444; } 50% { text-shadow: 0 0 40px #ef4444, 0 0 80px #ef4444, 0 0 120px #991b1b; } }
    #gameEndOverlay {
      display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 60;
      background: rgba(0,0,0,0.75); backdrop-filter: blur(4px);
    }
    .game-end-panel {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #1a1a2e 100%);
      border: 2px solid #333; border-radius: 12px; padding: 24px 32px; min-width: 500px; max-width: 700px;
      animation: gameEndSlideIn 0.5s ease-out;
      box-shadow: 0 0 40px rgba(0,0,0,0.5);
    }
    .game-end-title {
      text-align: center; font-size: 42px; font-weight: 900; letter-spacing: 6px; margin-bottom: 4px;
    }
    .game-end-title.victory { color: #10b981; animation: victoryGlow 2s ease-in-out infinite; }
    .game-end-title.defeat { color: #ef4444; animation: defeatGlow 2s ease-in-out infinite; }
    .game-end-subtitle { text-align: center; font-size: 13px; color: #94a3b8; margin-bottom: 16px; }
    .game-end-stats { width: 100%; border-collapse: collapse; margin-bottom: 16px; }
    .game-end-stats th { font-size: 10px; color: #64748b; text-transform: uppercase; text-align: left; padding: 4px 8px; border-bottom: 1px solid #333; }
    .game-end-stats td { font-size: 12px; padding: 6px 8px; border-bottom: 1px solid #1e293b; }
    .game-end-stats tr.me td { color: #a78bfa; font-weight: bold; }
    .game-end-xp {
      text-align: center; margin-top: 12px; padding: 12px; border-radius: 8px;
      background: linear-gradient(90deg, rgba(124,58,237,0.1), rgba(167,139,250,0.15), rgba(124,58,237,0.1));
      border: 1px solid rgba(124,58,237,0.3);
    }
    .game-end-xp-amount { font-size: 28px; font-weight: 900; color: #a78bfa; }
    .game-end-xp-bar { height: 8px; background: #1e293b; border-radius: 4px; margin-top: 8px; overflow: hidden; }
    .game-end-xp-bar-fill { height: 100%; background: linear-gradient(90deg, #7c3aed, #a78bfa); border-radius: 4px; animation: xpBarFill 1.5s ease-out; }
    .game-end-timer { text-align: center; font-size: 11px; color: #64748b; margin-top: 10px; }

    /* ‚îÄ‚îÄ Loot Drop Section ‚îÄ‚îÄ */
    .game-end-loot { margin-top: 12px; padding: 10px; background: rgba(245,158,11,0.08); border: 1px solid rgba(245,158,11,0.3); border-radius: 8px; }
    .game-end-loot h4 { font-size: 12px; color: #f59e0b; margin-bottom: 6px; text-align: center; text-transform: uppercase; letter-spacing: 1px; }
    .loot-items { display: flex; gap: 6px; flex-wrap: wrap; justify-content: center; }
    .loot-item {
      background: #1a1a2e; border: 1px solid #444; border-radius: 6px; padding: 6px 8px; text-align: center; min-width: 80px;
      cursor: default; transition: border-color 0.2s;
    }
    .loot-item:hover { border-color: #a78bfa; }
    .loot-item .loot-icon { font-size: 18px; }
    .loot-item .loot-name { font-size: 9px; color: #e2e8f0; margin-top: 2px; }
    .loot-item .loot-main { font-size: 8px; color: #a78bfa; }
    .loot-item .loot-tier { font-size: 8px; font-weight: bold; }

    /* ‚îÄ‚îÄ Gear Panel (Sidebar) ‚îÄ‚îÄ */
    .gear-panel { background: #1a1a2e; border: 1px solid #f59e0b44; border-radius: 6px; padding: 6px; margin-top: 4px; }
    .gear-panel h3 { color: #f59e0b; }
    .gear-slots { display: grid; grid-template-columns: 1fr 1fr; gap: 3px; margin-bottom: 4px; }
    .gear-slot {
      background: #111; border: 1px solid #333; border-radius: 4px; padding: 4px; cursor: pointer;
      display: flex; align-items: center; gap: 4px; min-height: 32px; transition: border-color 0.15s;
    }
    .gear-slot:hover { border-color: #a78bfa; }
    .gear-slot.equipped { border-color: #f59e0b; }
    .gear-slot .gs-icon { font-size: 14px; flex-shrink: 0; width: 18px; text-align: center; }
    .gear-slot .gs-info { flex: 1; min-width: 0; overflow: hidden; }
    .gear-slot .gs-name { font-size: 8px; color: #ccc; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .gear-slot .gs-stat { font-size: 7px; color: #a78bfa; }
    .gear-slot .gs-empty { font-size: 8px; color: #555; font-style: italic; }
    .gear-weapon {
      background: #111; border: 1px solid #333; border-radius: 4px; padding: 5px; cursor: pointer;
      display: flex; align-items: center; gap: 6px; margin-bottom: 4px; transition: border-color 0.15s;
    }
    .gear-weapon:hover { border-color: #a78bfa; }
    .gear-weapon.equipped { border-color: #ef4444; }
    .gear-weapon .gw-icon { font-size: 16px; }
    .gear-weapon .gw-info { flex: 1; }
    .gear-weapon .gw-name { font-size: 9px; color: #ccc; }
    .gear-weapon .gw-stat { font-size: 8px; color: #ef4444; }
    .gear-weapon .gw-empty { font-size: 9px; color: #555; font-style: italic; }
    .gear-summary { font-size: 8px; color: #94a3b8; margin-top: 3px; display: flex; flex-wrap: wrap; gap: 4px; }
    .gear-summary span { background: #1e293b; padding: 1px 4px; border-radius: 3px; }

    /* ‚îÄ‚îÄ Inventory Modal ‚îÄ‚îÄ */
    .inv-modal {
      display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 100;
      background: rgba(0,0,0,0.8); backdrop-filter: blur(3px);
    }
    .inv-panel {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
      background: #1a1a2e; border: 2px solid #333; border-radius: 10px; padding: 16px;
      min-width: 360px; max-width: 500px; max-height: 70vh; overflow-y: auto;
    }
    .inv-panel h3 { color: #f59e0b; margin-bottom: 8px; font-size: 14px; }
    .inv-items { display: flex; flex-direction: column; gap: 4px; }
    .inv-row {
      display: flex; align-items: center; gap: 8px; background: #111; border: 1px solid #333;
      border-radius: 6px; padding: 6px 8px; cursor: pointer; transition: border-color 0.15s;
    }
    .inv-row:hover { border-color: #a78bfa; }
    .inv-row .inv-icon { font-size: 20px; flex-shrink: 0; }
    .inv-row .inv-info { flex: 1; }
    .inv-row .inv-name { font-size: 10px; color: #e2e8f0; }
    .inv-row .inv-main { font-size: 9px; color: #a78bfa; }
    .inv-row .inv-subs { font-size: 8px; color: #64748b; }
    .inv-row .inv-tier { font-size: 9px; font-weight: bold; }
    .inv-row .inv-actions { display: flex; gap: 4px; flex-shrink: 0; }
    .inv-row .inv-actions button { font-size: 9px; padding: 2px 6px; }
    .inv-empty { text-align: center; color: #555; font-size: 11px; padding: 20px; }
    .inv-close { position: absolute; top: 8px; right: 12px; background: #ef4444; font-size: 10px; padding: 2px 8px; }

    /* ‚îÄ‚îÄ Forge Panel ‚îÄ‚îÄ */
    .forge-panel { background: #1a1a2e; border: 1px solid #ff2d5544; border-radius: 6px; padding: 6px; margin-top: 4px; }
    .forge-panel h3 { color: #ff2d55; }
    .feather-count { display: flex; align-items: center; gap: 6px; font-size: 11px; color: #f59e0b; margin-bottom: 4px; }
    .feather-count .feather-num { font-weight: bold; font-size: 14px; color: #ff2d55; }
    .forge-grid { display: flex; flex-direction: column; gap: 3px; }
    .forge-row {
      display: flex; align-items: center; gap: 6px; background: #111; border: 1px solid #333;
      border-radius: 4px; padding: 4px 6px; font-size: 9px;
    }
    .forge-row.owned { border-color: #ff2d55; background: rgba(255,45,85,0.08); }
    .forge-row .fr-icon { font-size: 14px; flex-shrink: 0; }
    .forge-row .fr-info { flex: 1; min-width: 0; }
    .forge-row .fr-name { color: #ff2d55; font-weight: bold; }
    .forge-row .fr-stat { color: #a78bfa; font-size: 8px; }
    .forge-row .fr-cost { color: #f59e0b; font-size: 8px; }
    .forge-row button { font-size: 8px; padding: 2px 6px; flex-shrink: 0; }
    .set-bonus-list { margin-top: 4px; font-size: 8px; }
    .set-bonus-item { color: #666; padding: 1px 0; }
    .set-bonus-item.active { color: #ff2d55; font-weight: bold; }
  </style>
</head>
<body>
  <div id="app">
    <div id="sidebar">
      <h2>Manaya Raid</h2>
      <div id="profileDisplay" style="margin-bottom:4px"></div>
      <div id="status">Disconnected</div>

      <input id="username" type="hidden" value="Player1" />
      <div id="connectionSection">
        <h3>Connection</h3>
        <div class="inline-row">
          <input id="usernameVisible" placeholder="Username" value="Player1" oninput="document.getElementById('username').value=this.value" />
        </div>
        <div class="inline-row">
          <button onclick="connect()" id="btnConnect">Connect</button>
        </div>
      </div>

      <h3>Room</h3>
      <div class="inline-row">
        <button onclick="createRoom()" id="btnCreate" disabled>Create</button>
        <input id="roomCode" placeholder="Code" style="width:80px" />
        <button onclick="joinRoom()" id="btnJoin" disabled>Join</button>
      </div>
      <button onclick="refreshRoomList()" id="btnBrowse" disabled style="width:calc(100% - 4px);margin-top:4px;background:#2563eb">Browse Rooms</button>
      <div id="roomList" style="margin-top:4px;max-height:150px;overflow-y:auto"></div>

      <h3>Class & Difficulty</h3>
      <div class="inline-row">
        <select id="classSelect" onchange="selectClass()">
          <option value="">-- Classe --</option>
          <option value="tank">Tank</option>
          <option value="healer">Healer</option>
          <option value="dps_cac">Warrior</option>
          <option value="dps_range">Archer</option>
        </select>
        <select id="diffSelect" onchange="selectDifficulty()">
          <option value="NORMAL">Normal</option>
          <option value="HARD">Hard</option>
          <option value="NIGHTMARE">Nightmare</option>
          <option value="NIGHTMARE_PLUS">Nightmare+</option>
          <option value="NIGHTMARE_2">Nightmare++</option>
          <option value="NIGHTMARE_3">Nightmare+++</option>
        </select>
      </div>

      <h3>Hunters (3 max)</h3>
      <div id="hunterSelection" style="max-height:200px;overflow-y:auto;background:#111;border-radius:6px;padding:4px;margin-bottom:4px"></div>
      <div id="hunterSelected" style="font-size:10px;color:#a78bfa;margin-bottom:4px"></div>
      <input id="hunterLevel" type="hidden" value="30" />

      <div style="margin-top:4px">
        <button onclick="toggleReady()" id="btnReady" disabled class="success">Ready</button>
      </div>
      <div id="roomPlayers" class="room-players"></div>

      <div id="statsPanel" style="background:#1a1a2e;border:1px solid #7c3aed44;border-radius:6px;padding:6px;margin-top:4px;display:none">
        <h3 style="color:#a78bfa">Player Stats</h3>
        <div id="statPointsRemaining" style="font-size:10px;color:#f59e0b;margin-bottom:4px"></div>
        <div id="statAllocUI"></div>
        <button onclick="resetStatPoints()" style="width:100%;margin-top:4px;background:#ef4444;font-size:9px;padding:3px">Reset Stats</button>
      </div>

      <div class="gear-panel" id="gearPanel" style="display:none">
        <h3>√âquipement Raid</h3>
        <div class="gear-weapon" id="gearWeaponSlot" onclick="openInventory('weapon')">
          <span class="gw-icon">‚öîÔ∏è</span>
          <div class="gw-info"><span class="gw-empty">Aucune arme</span></div>
        </div>
        <div class="gear-slots" id="gearSlots"></div>
        <div class="gear-summary" id="gearSummary"></div>
        <button onclick="openInventory('all')" style="width:100%;margin-top:3px;background:#b45309;font-size:9px;padding:3px">Inventaire</button>
      </div>

      <div class="forge-panel" id="forgePanel" style="display:none">
        <h3>Forge de Manaya</h3>
        <div class="feather-count">
          <span>ü™∂</span> Plumes: <span class="feather-num" id="featherCount">0</span>
        </div>
        <div class="forge-grid" id="forgeGrid"></div>
        <div class="set-bonus-list" id="setBonusList"></div>
      </div>

      <div class="sim-panel" id="simPanel">
        <h3>Mode Entrainement</h3>
        <div class="sim-toggle">
          <input type="checkbox" id="simToggle" onchange="toggleSimulation()" />
          <label for="simToggle">God Mode (invincible, pour tester les patterns)</label>
        </div>
        <div id="simControls" style="display:none">
          <label>Set Boss HP %</label>
          <div class="inline-row">
            <button onclick="simSetBossHp(90)">90%</button>
            <button onclick="simSetBossHp(75)">75%</button>
            <button onclick="simSetBossHp(50)">50%</button>
            <button onclick="simSetBossHp(30)">30%</button>
            <button onclick="simSetBossHp(20)">20%</button>
            <button onclick="simSetBossHp(8)">8%</button>
          </div>
          <div class="inline-row" style="margin-top:3px">
            <button onclick="simFullHeal()">Full Heal</button>
            <button onclick="simKillAdds()">Kill Adds</button>
            <button onclick="simSpawnAdds()">Spawn Adds</button>
          </div>
        </div>
      </div>

      <div class="controls-info">
        <h3>Controls</h3>
        <kbd>Z</kbd><kbd>Q</kbd><kbd>S</kbd><kbd>D</kbd> Move | <kbd>Space</kbd> Dodge<br>
        <kbd>Hold LMB</kbd> Auto-Attack Combo | <kbd>RMB</kbd> Block/Secondary<br>
        <span style="color:#f59e0b;font-size:8px">Cancel Block: ATK1+2 ‚Üí RMB ‚Üí repeat = + DPS</span><br>
        <kbd>A</kbd> Skill 1 | <kbd>E</kbd> Skill 2 | <kbd>R</kbd> Ultimate<br>
        <kbd>1</kbd><kbd>2</kbd><kbd>3</kbd> Summon Hunter
      </div>

      <h3>Log</h3>
      <div id="log"></div>
    </div>

    <div id="game">
      <canvas id="canvas"></canvas>

      <div class="boss-hud" id="bossHud" style="display:none">
        <div class="boss-hud-name" id="bossName">MANAYA</div>
        <div class="boss-bar-outer">
          <div class="boss-bar-bg" id="bossBg"></div>
          <div class="boss-bar-fill" id="bossFill"></div>
          <div class="boss-bar-text" id="bossText"></div>
        </div>
        <div class="boss-bar-info" id="bossInfo"></div>
        <div class="boss-shield-bar" id="shieldBar"><div class="boss-shield-fill" id="shieldFill"></div></div>
        <div class="boss-rage-info" id="bossRageInfo"></div>
      </div>

      <div class="party-hud" id="partyHud" style="display:none"></div>
      <div class="game-timer" id="gameTimer"></div>
      <div id="versionTag" style="position:absolute;bottom:6px;right:10px;font-size:10px;color:rgba(255,255,255,0.3);z-index:5;pointer-events:none;"></div>

      <div class="dps-panel" id="dpsPanel" style="display:none">
        <div class="dps-title">DPS Meter</div>
        <div id="dpsContent"></div>
      </div>

      <div class="buff-display" id="buffDisplay"></div>

      <!-- Player HP/Mana at bottom -->
      <div class="player-hud" id="playerHud" style="display:none">
        <div class="player-hud-name" id="playerHudName"></div>
        <div class="player-hp-outer">
          <div class="player-hp-fill" id="playerHpFill"></div>
          <div class="player-hp-text" id="playerHpText"></div>
        </div>
        <div class="player-mana-outer">
          <div class="player-mana-fill" id="playerManaFill"></div>
          <div class="player-mana-text" id="playerManaText"></div>
        </div>
        <div class="player-endurance-outer" id="playerEnduranceOuter">
          <div class="player-endurance-fill" id="playerEnduranceFill"></div>
          <div class="player-endurance-text" id="playerEnduranceText"></div>
        </div>
      </div>

      <div class="hunter-bar" id="hunterBar" style="display:none"></div>
      <div class="skill-bar" id="skillBar" style="display:none"></div>

      <!-- Death Overlay -->
      <div id="deathOverlay" style="display:none;position:absolute;top:0;left:0;right:0;bottom:0;z-index:50;pointer-events:none">
        <div style="position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5)"></div>
        <div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center">
          <div style="font-size:64px;font-weight:900;color:#ef4444;text-shadow:0 0 30px #ef4444,0 0 60px #991b1b;letter-spacing:8px;animation:deathPulse 1.5s ease-in-out infinite">MORT</div>
          <div id="deathRezMsg" style="margin-top:16px;font-size:16px;color:#94a3b8;text-shadow:0 0 5px #000"></div>
          <div style="margin-top:8px;font-size:12px;color:#64748b" id="deathTimer"></div>
        </div>
      </div>

      <!-- Game End Results Overlay -->
      <div id="gameEndOverlay">
        <div class="game-end-panel">
          <div id="gameEndTitle" class="game-end-title"></div>
          <div id="gameEndSubtitle" class="game-end-subtitle"></div>
          <table class="game-end-stats">
            <thead>
              <tr>
                <th>Joueur</th>
                <th>Classe</th>
                <th>D√©g√¢ts</th>
                <th>Soins</th>
                <th>Re√ßus</th>
                <th>Morts</th>
                <th>XP</th>
              </tr>
            </thead>
            <tbody id="gameEndStatsBody"></tbody>
          </table>
          <div id="gameEndXpSection" class="game-end-xp">
            <div style="font-size:11px;color:#94a3b8;margin-bottom:4px">XP GAGN√âE</div>
            <div id="gameEndXpAmount" class="game-end-xp-amount"></div>
            <div id="gameEndLevelInfo" style="font-size:11px;color:#64748b;margin-top:4px"></div>
            <div class="game-end-xp-bar">
              <div id="gameEndXpBarFill" class="game-end-xp-bar-fill"></div>
            </div>
          </div>
          <div id="gameEndLoot" class="game-end-loot" style="display:none">
            <h4>üéÅ Butin obtenu</h4>
            <div class="loot-items" id="gameEndLootItems"></div>
          </div>
          <div id="gameEndTimer" class="game-end-timer"></div>
        </div>
      </div>

      <!-- Inventory Modal -->
      <div class="inv-modal" id="invModal" onclick="if(event.target===this)closeInventory()">
        <div class="inv-panel">
          <button class="inv-close" onclick="closeInventory()">‚úï</button>
          <h3 id="invTitle">Inventaire</h3>
          <div class="inv-items" id="invItems"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ‚îÄ‚îÄ Hunter Data ‚îÄ‚îÄ
    const HUNTER_LIST = {
      h_kanae:     { name: 'Tawata Kanae', element: 'fire', class: 'assassin', rarity: 'mythique' },
      h_stark:     { name: 'Stark', element: 'fire', class: 'tank', rarity: 'mythique' },
      h_fern:      { name: 'Fern', element: 'fire', class: 'mage', rarity: 'legendaire' },
      h_choi:      { name: 'Choi Jong-In', element: 'fire', class: 'mage', rarity: 'mythique' },
      h_megumin:   { name: 'Megumin', element: 'fire', class: 'mage', rarity: 'mythique' },
      h_chae_in:   { name: 'Cha Hae-In', element: 'water', class: 'assassin', rarity: 'mythique' },
      h_frieren:   { name: 'Frieren', element: 'water', class: 'mage', rarity: 'mythique' },
      h_alicia:    { name: 'Alicia Blanche', element: 'water', class: 'assassin', rarity: 'legendaire' },
      h_seo:       { name: 'Seo Jiwoo', element: 'water', class: 'support', rarity: 'legendaire' },
      h_kurisu:    { name: 'Kurisu Makise', element: 'water', class: 'mage', rarity: 'mythique' },
      h_ilhwan:    { name: 'Ilhwan', element: 'shadow', class: 'assassin', rarity: 'mythique' },
      h_silverbaek:{ name: 'Baek Yoonho', element: 'shadow', class: 'fighter', rarity: 'mythique' },
      h_kaneki:    { name: 'Ken Kaneki', element: 'shadow', class: 'fighter', rarity: 'mythique' },
      h_saber:     { name: 'Saber', element: 'shadow', class: 'fighter', rarity: 'mythique' },
      h_guts:      { name: 'Guts', element: 'shadow', class: 'fighter', rarity: 'mythique' },
      h_2b:        { name: '2B', element: 'shadow', class: 'assassin', rarity: 'mythique' },
    };

    const ELEMENT_ICONS = { fire: '\u{1F525}', water: '\u{1F4A7}', shadow: '\u{1F31F}' };
    const MANAYA_VERSION = 'v1.03';
    const CLASS_COLORS = { tank: '#3b82f6', healer: '#10b981', dps_cac: '#ef4444', dps_range: '#f59e0b' };
    const CLASS_LABELS = { tank: 'Tank', healer: 'Healer', dps_cac: 'Warrior', dps_range: 'Archer' };
    const BAR_COLORS = ['#ef4444','#f97316','#eab308','#22c55e','#3b82f6','#8b5cf6','#ec4899'];
    const HP_BARS = 150;

    // ‚îÄ‚îÄ Boss Sprite ‚îÄ‚îÄ
    const bossImg = new Image();
    bossImg.src = '/manayaBoss.png';
    let bossImgLoaded = false;
    bossImg.onload = () => { bossImgLoaded = true; };
    const BOSS_SPRITE_SIZE = 210; // x1.5 bigger

    // ‚îÄ‚îÄ Player Sprites ‚îÄ‚îÄ
    // Default (Sung) - used by DPS/Healer
    const playerIdleImg = new Image();
    playerIdleImg.src = 'https://res.cloudinary.com/dbg7m8qjd/image/upload/v1771687526/Sung_eztua4.png';
    let playerIdleLoaded = false;
    playerIdleImg.onload = () => { playerIdleLoaded = true; };

    const playerAtkImg = new Image();
    playerAtkImg.src = 'https://res.cloudinary.com/dbg7m8qjd/image/upload/v1771692299/SungAtk_sq1inu.png';
    let playerAtkLoaded = false;
    playerAtkImg.onload = () => { playerAtkLoaded = true; };

    // Tank sprites
    const tankIdleImg = new Image();
    tankIdleImg.src = 'https://res.cloudinary.com/dbg7m8qjd/image/upload/v1771702659/TankPosture_wdom1k.png';
    let tankIdleLoaded = false;
    tankIdleImg.onload = () => { tankIdleLoaded = true; };

    const tankAtkImg = new Image();
    tankAtkImg.src = 'https://res.cloudinary.com/dbg7m8qjd/image/upload/v1771702659/TankAtking_y0awt2.png';
    let tankAtkLoaded = false;
    tankAtkImg.onload = () => { tankAtkLoaded = true; };

    const tankBlockImg = new Image();
    tankBlockImg.src = 'https://res.cloudinary.com/dbg7m8qjd/image/upload/v1771702659/TankBlock_zfgfuq.png';
    let tankBlockLoaded = false;
    tankBlockImg.onload = () => { tankBlockLoaded = true; };

    // ‚îÄ‚îÄ Add (Tentacle) Sprite ‚îÄ‚îÄ
    const addImg = new Image();
    addImg.src = 'https://res.cloudinary.com/dbg7m8qjd/image/upload/v1771729827/tentaculeManaya_dkn8yg.png';
    let addImgLoaded = false;
    addImg.onload = () => { addImgLoaded = true; };
    const ADD_SPRITE_SIZE = { minion: 42, elite: 56, caster: 38 };

    // ‚îÄ‚îÄ Arena Map ‚îÄ‚îÄ
    const arenaMapImg = new Image();
    arenaMapImg.src = 'https://res.cloudinary.com/dbg7m8qjd/image/upload/v1771694314/mapManaya_gjdwpd.jpg';
    let arenaMapLoaded = false;
    arenaMapImg.onload = () => { arenaMapLoaded = true; };

    const PLAYER_SPRITE_SIZE = 56;
    let playerAttackTimers = {}; // playerId -> timestamp of last attack

    // ‚îÄ‚îÄ Screen Shake ‚îÄ‚îÄ
    let screenShake = { x: 0, y: 0, intensity: 0, decay: 0.92 };

    function triggerScreenShake(intensity) {
      screenShake.intensity = Math.max(screenShake.intensity, intensity);
    }

    // ‚îÄ‚îÄ Particles ‚îÄ‚îÄ
    let particles = [];
    function spawnParticles(x, y, color, count, speed, size) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const spd = speed * (0.5 + Math.random() * 0.5);
        particles.push({
          x, y, vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd,
          size: size * (0.5 + Math.random() * 0.5), color, alpha: 1, life: 0.5 + Math.random() * 0.5, age: 0,
        });
      }
    }

    // ‚îÄ‚îÄ Floating Damage Numbers ‚îÄ‚îÄ
    let floatingNumbers = []; // { x, y, text, color, alpha, vy, age }

    function addFloatingNumber(x, y, amount, crit, isHeal) {
      const color = isHeal ? '#10b981' : (crit ? '#ffd700' : '#ffffff');
      const size = crit ? 22 : (isHeal ? 16 : 18);
      const prefix = isHeal ? '+' : '';
      floatingNumbers.push({
        x: x + (Math.random() - 0.5) * 40,
        y: y - 30,
        text: prefix + formatNum(amount),
        color, size, alpha: 1, vy: -60, age: 0, maxAge: 1.2,
        bold: crit,
      });
    }

    // ‚îÄ‚îÄ Battle Music ‚îÄ‚îÄ
    const battleMusic = new Audio('https://res.cloudinary.com/dbg7m8qjd/video/upload/v1771713175/NierManaya_lknb5x.mp3');
    battleMusic.loop = true;
    battleMusic.volume = 0.35;

    // ‚îÄ‚îÄ Warning Sounds (Web Audio API) ‚îÄ‚îÄ
    let audioCtx = null;
    function getAudioCtx() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      return audioCtx;
    }
    function playWarningBeep(urgency) {
      // urgency: 0 (calm) ‚Üí 1 (imminent danger)
      try {
        const ctx = getAudioCtx();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        // Higher pitch = more urgent (300Hz ‚Üí 800Hz)
        osc.frequency.value = 300 + urgency * 500;
        osc.type = 'sine';
        gain.gain.value = 0.08 + urgency * 0.12; // 0.08 ‚Üí 0.20
        osc.start();
        // Short beep: shorter = more urgent (120ms ‚Üí 50ms)
        const dur = 0.12 - urgency * 0.07;
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + dur);
        osc.stop(ctx.currentTime + dur + 0.01);
      } catch {}
    }
    function playExplosionBoom() {
      try {
        const ctx = getAudioCtx();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.type = 'sawtooth';
        osc.frequency.value = 60;
        osc.frequency.exponentialRampToValueAtTime(25, ctx.currentTime + 0.4);
        gain.gain.value = 0.25;
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.5);
        osc.start();
        osc.stop(ctx.currentTime + 0.6);
      } catch {}
    }

    // ‚îÄ‚îÄ State (must be declared before auto-login uses them) ‚îÄ‚îÄ
    let ws = null, myId = null, gameState = null, roomInfo = null, inRoom = false;
    let keys = {}, mouseAngle = 0, lastAimSent = 0, gameStartTime = 0;

    // ‚îÄ‚îÄ Auto-login from URL params ‚îÄ‚îÄ
    const urlParams = new URLSearchParams(window.location.search);
    const autoUser = urlParams.get('user');
    if (autoUser) {
      document.getElementById('username').value = autoUser;
      document.getElementById('usernameVisible').value = autoUser;
      // Auto-connect after a short delay
      setTimeout(() => connect(), 300);
    }

    // ‚îÄ‚îÄ Hunter Box (owned hunters from ShadowColosseum) ‚îÄ‚îÄ
    // Passed via URL param ?hunters=h_kanae,h_chae_in,...
    // Falls back to all hunters if no box data
    const hunterBoxParam = urlParams.get('hunters');
    let ownedHunters = [];
    if (hunterBoxParam) {
      ownedHunters = hunterBoxParam.split(',').filter(id => HUNTER_LIST[id]);
    }
    // If no box data, give all hunters (dev mode)
    if (ownedHunters.length === 0) {
      ownedHunters = Object.keys(HUNTER_LIST);
    }

    // Hunter level from URL or default
    const hunterLvlParam = urlParams.get('hlvl');
    if (hunterLvlParam) document.getElementById('hunterLevel').value = hunterLvlParam;

    // Auto-select class from URL
    const autoClass = urlParams.get('class');
    if (autoClass && document.getElementById('classSelect')) {
      document.getElementById('classSelect').value = autoClass;
    }

    // Auto-load stat points from URL (JSON encoded)
    // These come from builderberu.com character sheet and should be auto-applied
    let autoStatPoints = null;
    try { const spParam = urlParams.get('sp'); if (spParam) autoStatPoints = JSON.parse(spParam); } catch {}
    let autoStatPointsApplied = false;

    // ‚îÄ‚îÄ Hunter Selection UI (pick 3, no duplicates) ‚îÄ‚îÄ
    // Auto-select first 3 owned hunters (from URL params)
    let selectedHunters = [null, null, null];
    let selectedCount = 0;
    if (ownedHunters.length >= 3) {
      selectedHunters = [ownedHunters[0], ownedHunters[1], ownedHunters[2]];
      selectedCount = 3;
    } else if (ownedHunters.length > 0) {
      for (let i = 0; i < ownedHunters.length && i < 3; i++) {
        selectedHunters[i] = ownedHunters[i];
        selectedCount++;
      }
    }

    function buildHunterSelectionUI() {
      const container = document.getElementById('hunterSelection');
      const ELEM_COLORS = { fire: '#ef4444', water: '#3b82f6', shadow: '#a855f7', dark: '#a855f7' };
      let html = '';
      for (const hId of ownedHunters) {
        const h = HUNTER_LIST[hId];
        if (!h) continue;
        const isSelected = selectedHunters.includes(hId);
        const elemColor = ELEM_COLORS[h.element] || '#888';
        const icon = ELEMENT_ICONS[h.element] || '';
        html += '<div class="hunter-pick' + (isSelected ? ' picked' : '') + '" data-hid="' + hId + '" onclick="toggleHunterPick(\'' + hId + '\')" ' +
          'style="display:flex;align-items:center;gap:6px;padding:4px 6px;margin:2px 0;border-radius:4px;cursor:pointer;' +
          'background:' + (isSelected ? 'rgba(124,58,237,0.25)' : 'rgba(0,0,0,0.3)') + ';' +
          'border:1px solid ' + (isSelected ? '#7c3aed' : '#333') + '">' +
          '<span style="font-size:12px">' + icon + '</span>' +
          '<span style="font-size:11px;color:' + (isSelected ? '#e2e8f0' : '#94a3b8') + '">' + h.name + '</span>' +
          '<span style="font-size:8px;color:' + elemColor + ';margin-left:auto">' + (h.rarity === 'mythique' ? '\u2605' : '\u2606') + '</span>' +
          (isSelected ? '<span style="font-size:9px;color:#10b981;font-weight:bold">\u2714</span>' : '') +
          '</div>';
      }
      container.innerHTML = html;
      updateHunterSelectedDisplay();
    }

    function toggleHunterPick(hId) {
      const idx = selectedHunters.indexOf(hId);
      if (idx >= 0) {
        // Deselect
        selectedHunters[idx] = null;
        selectedCount--;
      } else if (selectedCount < 3) {
        // Select into first empty slot
        const emptySlot = selectedHunters.indexOf(null);
        if (emptySlot >= 0) {
          selectedHunters[emptySlot] = hId;
          selectedCount++;
        }
      }
      buildHunterSelectionUI();
      // Auto-apply when 3 selected
      if (selectedCount === 3 || selectedCount > 0) {
        selectHunters();
      }
    }

    function updateHunterSelectedDisplay() {
      const el = document.getElementById('hunterSelected');
      const names = selectedHunters.filter(Boolean).map(id => HUNTER_LIST[id]?.name || id);
      if (names.length === 0) {
        el.textContent = 'Choisis 3 hunters pour le combat';
      } else {
        el.innerHTML = '<span style="color:#10b981">' + names.length + '/3</span> ' + names.join(', ');
      }
    }

    // Build UI on load
    buildHunterSelectionUI();

    // ‚îÄ‚îÄ Player Profile (localStorage) ‚îÄ‚îÄ
    const PROFILE_KEY = 'manaya_raid_profile';
    function xpForLevel(level) { return level <= 1 ? 0 : Math.floor(500 * Math.pow(level, 1.5)); }
    function loadProfile() {
      try {
        const data = JSON.parse(localStorage.getItem(PROFILE_KEY));
        if (data && data.level) return data;
      } catch {}
      return null;
    }
    function saveProfile(profile) {
      localStorage.setItem(PROFILE_KEY, JSON.stringify(profile));
      // Sync to server for cross-domain access (builderberu.com character sheet)
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'save_profile', profile }));
      }
    }
    function getOrCreateProfile(username) {
      let p = loadProfile();
      if (p && p.username === username) {
        // Auto-apply builderberu stat points from URL (only once per session)
        if (autoStatPoints && !autoStatPointsApplied) {
          autoStatPointsApplied = true;
          if (!p.allocatedStats) p.allocatedStats = { hp: 0, atk: 0, def: 0, spd: 0, crit: 0, res: 0 };
          for (const [stat, val] of Object.entries(autoStatPoints)) {
            if (typeof val === 'number' && val > 0 && STAT_NAMES[stat]) {
              p.allocatedStats[stat] = val;
            }
          }
          saveProfile(p);
          updateStatsPanel();
        }
        return p;
      }
      // New profile
      p = {
        username, level: 1, xp: 0, totalXp: 0,
        gamesPlayed: 0, victories: 0, defeats: 0,
        classStats: { tank: { gp: 0, w: 0 }, healer: { gp: 0, w: 0 }, dps_cac: { gp: 0, w: 0 }, dps_range: { gp: 0, w: 0 } },
        bestTime: null, createdAt: Date.now(),
      };
      // Auto-apply builderberu stat points on new profile too
      if (autoStatPoints) {
        autoStatPointsApplied = true;
        p.allocatedStats = { hp: 0, atk: 0, def: 0, spd: 0, crit: 0, res: 0 };
        for (const [stat, val] of Object.entries(autoStatPoints)) {
          if (typeof val === 'number' && val > 0 && STAT_NAMES[stat]) {
            p.allocatedStats[stat] = val;
          }
        }
      }
      saveProfile(p);
      return p;
    }
    function addXpToProfile(xpReward, victory, cls, clearTime) {
      const username = document.getElementById('username').value || 'Player';
      const profile = getOrCreateProfile(username);
      profile.gamesPlayed++;
      if (victory) profile.victories++;
      else profile.defeats++;
      if (cls && profile.classStats[cls]) {
        profile.classStats[cls].gp++;
        if (victory) profile.classStats[cls].w++;
      }
      if (victory && clearTime && (!profile.bestTime || clearTime < profile.bestTime)) {
        profile.bestTime = Math.round(clearTime);
      }
      profile.xp += xpReward;
      profile.totalXp += xpReward;
      // Level up check
      while (profile.level < 50) {
        const needed = xpForLevel(profile.level + 1);
        if (profile.xp >= needed) {
          profile.xp -= needed;
          profile.level++;
          log('LEVEL UP! Level ' + profile.level + ' !', 'heal');
        } else break;
      }
      saveProfile(profile);
      updateProfileDisplay();
      updateStatsPanel();
      return profile;
    }
    function updateProfileDisplay() {
      const el = document.getElementById('profileDisplay');
      const profile = loadProfile();
      if (!profile) { el.innerHTML = '<span style="color:#666;font-size:10px">Connecte-toi pour cr\u00e9er ton profil</span>'; return; }
      const needed = xpForLevel(profile.level + 1);
      const xpPct = needed > 0 ? Math.min(100, (profile.xp / needed) * 100) : 100;
      const lvColor = profile.level >= 40 ? '#f59e0b' : profile.level >= 20 ? '#a78bfa' : '#38bdf8';
      el.innerHTML =
        '<div style="background:linear-gradient(135deg,rgba(124,58,237,0.15),rgba(30,30,60,0.4));border:1px solid #7c3aed44;border-radius:8px;padding:8px 10px;margin-bottom:6px">' +
        '<div style="display:flex;align-items:center;gap:8px;margin-bottom:4px">' +
        '<div style="font-size:20px;font-weight:bold;color:' + lvColor + ';text-shadow:0 0 8px ' + lvColor + '55">Lv.' + profile.level + '</div>' +
        '<div style="font-size:13px;color:#e2e8f0;font-weight:600">' + profile.username + '</div>' +
        '</div>' +
        '<div style="height:8px;background:#1a1a2e;border-radius:4px;overflow:hidden;margin:4px 0;border:1px solid #333">' +
        '<div style="height:100%;width:' + xpPct + '%;background:linear-gradient(90deg,#7c3aed,#a78bfa);border-radius:3px;transition:width 0.3s"></div></div>' +
        '<div style="font-size:9px;color:#94a3b8;display:flex;justify-content:space-between">' +
        '<span>XP: ' + profile.xp + ' / ' + needed + '</span>' +
        '<span style="color:#a78bfa">' + Math.round(xpPct) + '%</span></div>' +
        '<div style="font-size:9px;color:#64748b;margin-top:3px">' +
        '\u2694 ' + profile.gamesPlayed + ' games | ' +
        '<span style="color:#10b981">\u2714 ' + profile.victories + 'W</span> ' +
        '<span style="color:#ef4444">\u2716 ' + profile.defeats + 'L</span>' +
        (profile.bestTime ? ' | \u23F1 ' + Math.floor(profile.bestTime / 60) + ':' + String(Math.floor(profile.bestTime % 60)).padStart(2, '0') : '') +
        '</div></div>';
    }

    // ‚îÄ‚îÄ Stat Allocation System ‚îÄ‚îÄ
    const STAT_POINTS_PER_LEVEL = 3;
    const STAT_NAMES = { hp: 'HP', atk: 'ATK', def: 'DEF', spd: 'SPD', crit: 'CRIT', res: 'RES' };
    const STAT_COLORS = { hp: '#10b981', atk: '#ef4444', def: '#3b82f6', spd: '#f59e0b', crit: '#f97316', res: '#8b5cf6' };
    const STAT_PER_POINT = { hp: 150, atk: 3, def: 4, spd: 2, crit: 0.8, res: 1.5 };

    function getStatPoints(profile) {
      if (!profile) return { allocated: {}, free: 0 };
      const totalPoints = Math.max(0, (profile.level - 1)) * STAT_POINTS_PER_LEVEL;
      const allocated = profile.allocatedStats || { hp: 0, atk: 0, def: 0, spd: 0, crit: 0, res: 0 };
      const used = Object.values(allocated).reduce((s, v) => s + v, 0);
      return { allocated, free: totalPoints - used, total: totalPoints };
    }

    function allocateStat(stat) {
      const profile = loadProfile();
      if (!profile) return;
      const { free } = getStatPoints(profile);
      if (free <= 0) return;
      if (!profile.allocatedStats) profile.allocatedStats = { hp: 0, atk: 0, def: 0, spd: 0, crit: 0, res: 0 };
      profile.allocatedStats[stat] = (profile.allocatedStats[stat] || 0) + 1;
      saveProfile(profile);
      updateStatsPanel();
      updateProfileDisplay();
    }

    function resetStatPoints() {
      const profile = loadProfile();
      if (!profile) return;
      profile.allocatedStats = { hp: 0, atk: 0, def: 0, spd: 0, crit: 0, res: 0 };
      saveProfile(profile);
      updateStatsPanel();
      updateProfileDisplay();
    }

    function updateStatsPanel() {
      const profile = loadProfile();
      const panel = document.getElementById('statsPanel');
      const ui = document.getElementById('statAllocUI');
      const remaining = document.getElementById('statPointsRemaining');
      if (!profile || profile.level <= 1) { panel.style.display = 'none'; return; }
      panel.style.display = 'block';

      const { allocated, free, total } = getStatPoints(profile);
      remaining.innerHTML = 'Points: <span style="color:#10b981;font-weight:bold">' + free + '</span> / ' + total + ' disponibles';

      let html = '';
      for (const [stat, label] of Object.entries(STAT_NAMES)) {
        const pts = allocated[stat] || 0;
        const bonus = Math.round(pts * STAT_PER_POINT[stat] * 10) / 10;
        const color = STAT_COLORS[stat];
        html += '<div style="display:flex;align-items:center;gap:4px;margin:2px 0;font-size:10px">' +
          '<span style="color:' + color + ';width:35px;font-weight:bold">' + label + '</span>' +
          '<span style="color:#94a3b8;width:30px;text-align:right">' + pts + '</span>' +
          '<span style="color:#555;font-size:8px;width:55px">(+' + bonus + ')</span>' +
          '<button onclick="allocateStat(\'' + stat + '\')" style="padding:1px 6px;font-size:9px;' + (free > 0 ? '' : 'opacity:0.3;pointer-events:none') + '">+</button>' +
          '</div>';
      }
      ui.innerHTML = html;
    }

    // Initialize profile display
    updateProfileDisplay();
    updateStatsPanel();

    // ‚îÄ‚îÄ Raid Gear System (Client) ‚îÄ‚îÄ
    const INVENTORY_KEY = 'manaya_raid_inventory';
    const EQUIPPED_KEY = 'manaya_raid_equipped';

    const GEAR_SLOT_DEFS = [
      { id: 'helmet',   name: 'Casque',   icon: 'ü™ñ' },
      { id: 'chest',    name: 'Plastron', icon: 'üõ°Ô∏è' },
      { id: 'gloves',   name: 'Gants',    icon: 'üß§' },
      { id: 'boots',    name: 'Bottes',   icon: 'üë¢' },
      { id: 'necklace', name: 'Collier',  icon: 'üìø' },
      { id: 'bracelet', name: 'Bracelet', icon: '‚åö' },
      { id: 'ring',     name: 'Anneau',   icon: 'üíç' },
      { id: 'earring',  name: 'Boucles',  icon: '‚ú®' },
    ];

    const STAT_LABELS = {
      hp_flat: 'HP', hp_pct: 'HP%', atk_flat: 'ATK', atk_pct: 'ATK%',
      def_flat: 'DEF', def_pct: 'DEF%', spd_flat: 'SPD', crit_rate: 'CRIT',
      crit_dmg: 'CRIT DMG', res_flat: 'RES', mana_flat: 'Mana',
    };

    // ‚îÄ‚îÄ Manaya Set (T12) ‚îÄ‚îÄ
    const FEATHER_KEY = 'manaya_raid_feathers';
    const MANAYA_OWNED_KEY = 'manaya_set_owned'; // { weapon: true, helmet: true, ... }
    const MANAYA_SET_COLOR = '#ff2d55';

    const MANAYA_FEATHER_COST = {
      weapon: 3, helmet: 2, chest: 2, gloves: 2,
      boots: 1, necklace: 1, bracelet: 1, ring: 1, earring: 1,
    };

    const MANAYA_SET_PIECES = {
      weapon: {
        id: 'manaya_weapon', type: 'weapon', tier: 'T12', tierLabel: 'Manaya', tierColor: MANAYA_SET_COLOR,
        name: 'Griffe de Manaya', icon: 'ü©∏', isManayaSet: true, slot: 'weapon',
        atk: 300, bonusStat: 'crit_dmg', bonusValue: 40,
      },
      helmet: {
        id: 'manaya_helmet', tier: 'T12', tierLabel: 'Manaya', tierColor: MANAYA_SET_COLOR,
        slot: 'helmet', slotName: 'Casque', slotIcon: 'ü™ñ', name: 'Diad√®me de Manaya', isManayaSet: true,
        mainStat: { id: 'hp_flat', label: 'HP', value: 3500 },
        subs: [{ id: 'def_flat', label: 'DEF', value: 120 }, { id: 'res_flat', label: 'RES', value: 50 }],
      },
      chest: {
        id: 'manaya_chest', tier: 'T12', tierLabel: 'Manaya', tierColor: MANAYA_SET_COLOR,
        slot: 'chest', slotName: 'Plastron', slotIcon: 'üõ°Ô∏è', name: 'Plastron de Manaya', isManayaSet: true,
        mainStat: { id: 'atk_flat', label: 'ATK', value: 220 },
        subs: [{ id: 'def_flat', label: 'DEF', value: 100 }, { id: 'hp_flat', label: 'HP', value: 2000 }],
      },
      gloves: {
        id: 'manaya_gloves', tier: 'T12', tierLabel: 'Manaya', tierColor: MANAYA_SET_COLOR,
        slot: 'gloves', slotName: 'Gants', slotIcon: 'üß§', name: 'Serres de Manaya', isManayaSet: true,
        mainStat: { id: 'crit_rate', label: 'CRIT', value: 35 },
        subs: [{ id: 'crit_dmg', label: 'CRIT DMG', value: 55 }, { id: 'atk_flat', label: 'ATK', value: 80 }],
      },
      boots: {
        id: 'manaya_boots', tier: 'T12', tierLabel: 'Manaya', tierColor: MANAYA_SET_COLOR,
        slot: 'boots', slotName: 'Bottes', slotIcon: 'üë¢', name: 'Pas de Manaya', isManayaSet: true,
        mainStat: { id: 'spd_flat', label: 'SPD', value: 35 },
        subs: [{ id: 'def_flat', label: 'DEF', value: 60 }],
      },
      necklace: {
        id: 'manaya_necklace', tier: 'T12', tierLabel: 'Manaya', tierColor: MANAYA_SET_COLOR,
        slot: 'necklace', slotName: 'Collier', slotIcon: 'üìø', name: 'Pendentif de Manaya', isManayaSet: true,
        mainStat: { id: 'hp_pct', label: 'HP%', value: 30 },
        subs: [{ id: 'atk_pct', label: 'ATK%', value: 25 }],
      },
      bracelet: {
        id: 'manaya_bracelet', tier: 'T12', tierLabel: 'Manaya', tierColor: MANAYA_SET_COLOR,
        slot: 'bracelet', slotName: 'Bracelet', slotIcon: '‚åö', name: 'Cha√Æne de Manaya', isManayaSet: true,
        mainStat: { id: 'atk_pct', label: 'ATK%', value: 28 },
        subs: [{ id: 'def_pct', label: 'DEF%', value: 18 }],
      },
      ring: {
        id: 'manaya_ring', tier: 'T12', tierLabel: 'Manaya', tierColor: MANAYA_SET_COLOR,
        slot: 'ring', slotName: 'Anneau', slotIcon: 'üíç', name: 'Sceau de Manaya', isManayaSet: true,
        mainStat: { id: 'crit_rate', label: 'CRIT', value: 25 },
        subs: [{ id: 'res_flat', label: 'RES', value: 40 }],
      },
      earring: {
        id: 'manaya_earring', tier: 'T12', tierLabel: 'Manaya', tierColor: MANAYA_SET_COLOR,
        slot: 'earring', slotName: 'Boucles', slotIcon: '‚ú®', name: 'Larme de Manaya', isManayaSet: true,
        mainStat: { id: 'atk_pct', label: 'ATK%', value: 25 },
        subs: [{ id: 'hp_pct', label: 'HP%', value: 18 }, { id: 'mana_flat', label: 'Mana', value: 180 }],
      },
    };

    const MANAYA_SET_BONUSES = [
      { count: 2, label: '2P: ATK +12%, DEF +12%' },
      { count: 4, label: '4P: CRIT +18%, CRIT DMG +30%' },
      { count: 6, label: '6P: HP +22%, Mana +250, DMG +15%' },
      { count: 8, label: '8P: 3% chance/hit de stun Manaya' },
    ];

    function loadFeathers() { return parseInt(localStorage.getItem(FEATHER_KEY)) || 0; }
    function saveFeathers(n) { localStorage.setItem(FEATHER_KEY, String(n)); }
    function addFeathers(n) { saveFeathers(loadFeathers() + n); }
    function loadManayaOwned() {
      try { return JSON.parse(localStorage.getItem(MANAYA_OWNED_KEY)) || {}; } catch { return {}; }
    }
    function saveManayaOwned(obj) { localStorage.setItem(MANAYA_OWNED_KEY, JSON.stringify(obj)); }

    function forgeManayaPiece(slotId) {
      const cost = MANAYA_FEATHER_COST[slotId];
      const feathers = loadFeathers();
      const owned = loadManayaOwned();
      if (owned[slotId]) return; // Already owned
      if (feathers < cost) return; // Not enough feathers
      saveFeathers(feathers - cost);
      owned[slotId] = true;
      saveManayaOwned(owned);
      // Add piece to inventory
      const piece = { ...MANAYA_SET_PIECES[slotId] };
      addToInventory([piece]);
      updateForgePanel();
      updateGearPanel();
    }

    function countEquippedManayaPieces() {
      const eq = loadEquipped();
      let count = 0;
      if (eq.weapon?.isManayaSet) count++;
      for (const art of Object.values(eq.artifacts || {})) {
        if (art?.isManayaSet) count++;
      }
      return count;
    }

    function updateForgePanel() {
      const profile = loadProfile();
      const panel = document.getElementById('forgePanel');
      if (!profile) { panel.style.display = 'none'; return; }
      panel.style.display = 'block';

      const feathers = loadFeathers();
      document.getElementById('featherCount').textContent = feathers;

      const owned = loadManayaOwned();
      const grid = document.getElementById('forgeGrid');
      const allSlots = ['weapon', ...GEAR_SLOT_DEFS.map(s => s.id)];
      let html = '';

      for (const slotId of allSlots) {
        const piece = MANAYA_SET_PIECES[slotId];
        const cost = MANAYA_FEATHER_COST[slotId];
        const isOwned = !!owned[slotId];
        const canForge = !isOwned && feathers >= cost;
        const icon = piece.icon || (slotId === 'weapon' ? 'ü©∏' : GEAR_SLOT_DEFS.find(s => s.id === slotId)?.icon || 'üì¶');
        const mainLine = piece.type === 'weapon'
          ? 'ATK +' + piece.atk
          : piece.mainStat ? piece.mainStat.label + ' +' + piece.mainStat.value : '';

        html += '<div class="forge-row' + (isOwned ? ' owned' : '') + '">' +
          '<span class="fr-icon">' + icon + '</span>' +
          '<div class="fr-info">' +
          '<div class="fr-name">' + piece.name + '</div>' +
          '<div class="fr-stat">' + mainLine + '</div>' +
          '</div>' +
          '<div class="fr-cost">ü™∂' + cost + '</div>' +
          (isOwned
            ? '<span style="color:#10b981;font-size:9px;font-weight:bold">‚úì</span>'
            : '<button onclick="forgeManayaPiece(\'' + slotId + '\')" ' + (canForge ? 'class="success"' : 'disabled') + '>Forger</button>'
          ) +
          '</div>';
      }
      grid.innerHTML = html;

      // Set bonuses
      const setPieces = countEquippedManayaPieces();
      const bonusList = document.getElementById('setBonusList');
      let bonusHtml = '';
      for (const b of MANAYA_SET_BONUSES) {
        const active = setPieces >= b.count;
        bonusHtml += '<div class="set-bonus-item' + (active ? ' active' : '') + '">' +
          (active ? '‚ú¶ ' : '‚óã ') + b.label + '</div>';
      }
      bonusList.innerHTML = bonusHtml;
    }

    function loadInventory() {
      try { return JSON.parse(localStorage.getItem(INVENTORY_KEY)) || []; } catch { return []; }
    }
    function saveInventory(inv) { localStorage.setItem(INVENTORY_KEY, JSON.stringify(inv)); }
    function loadEquipped() {
      try { return JSON.parse(localStorage.getItem(EQUIPPED_KEY)) || { weapon: null, artifacts: {} }; } catch { return { weapon: null, artifacts: {} }; }
    }
    function saveEquipped(eq) {
      localStorage.setItem(EQUIPPED_KEY, JSON.stringify(eq));
      updateGearPanel();
      updateForgePanel();
    }

    function addToInventory(items) {
      const inv = loadInventory();
      for (const item of items) inv.push(item);
      saveInventory(inv);
    }

    function removeFromInventory(itemId) {
      let inv = loadInventory();
      inv = inv.filter(i => i.id !== itemId);
      saveInventory(inv);
    }

    function equipItem(item) {
      const eq = loadEquipped();
      if (item.type === 'weapon') {
        // Unequip current weapon ‚Üí back to inventory
        if (eq.weapon) addToInventory([eq.weapon]);
        eq.weapon = item;
        removeFromInventory(item.id);
      } else {
        // Artifact ‚Äî equip to its slot
        const slotId = item.slot;
        if (eq.artifacts[slotId]) addToInventory([eq.artifacts[slotId]]);
        eq.artifacts[slotId] = item;
        removeFromInventory(item.id);
      }
      saveEquipped(eq);
    }

    function unequipItem(slotId) {
      const eq = loadEquipped();
      if (slotId === 'weapon') {
        if (eq.weapon) { addToInventory([eq.weapon]); eq.weapon = null; }
      } else {
        if (eq.artifacts[slotId]) { addToInventory([eq.artifacts[slotId]]); delete eq.artifacts[slotId]; }
      }
      saveEquipped(eq);
    }

    function getGearBonuses() {
      const eq = loadEquipped();
      const b = {
        hp_flat: 0, hp_pct: 0, atk_flat: 0, atk_pct: 0, def_flat: 0, def_pct: 0,
        spd_flat: 0, crit_rate: 0, crit_dmg: 0, res_flat: 0, mana_flat: 0,
      };
      if (eq.weapon) {
        b.atk_flat += eq.weapon.atk || 0;
        if (eq.weapon.bonusStat && b[eq.weapon.bonusStat] !== undefined) {
          b[eq.weapon.bonusStat] += eq.weapon.bonusValue || 0;
        }
      }
      for (const art of Object.values(eq.artifacts)) {
        if (!art) continue;
        if (art.mainStat && b[art.mainStat.id] !== undefined) b[art.mainStat.id] += art.mainStat.value;
        for (const sub of (art.subs || [])) {
          if (b[sub.id] !== undefined) b[sub.id] += sub.value;
        }
      }
      return b;
    }

    function updateGearPanel() {
      const profile = loadProfile();
      const panel = document.getElementById('gearPanel');
      if (!profile) { panel.style.display = 'none'; return; }
      panel.style.display = 'block';

      const eq = loadEquipped();

      // Weapon slot
      const wSlot = document.getElementById('gearWeaponSlot');
      if (eq.weapon) {
        wSlot.className = 'gear-weapon equipped';
        wSlot.innerHTML =
          '<span class="gw-icon">' + (eq.weapon.icon || '‚öîÔ∏è') + '</span>' +
          '<div class="gw-info">' +
          '<div class="gw-name" style="color:' + (eq.weapon.tierColor || '#9ca3af') + '">' + eq.weapon.name + '</div>' +
          '<div class="gw-stat">ATK +' + eq.weapon.atk + (eq.weapon.bonusStat ? ' | ' + STAT_LABELS[eq.weapon.bonusStat] + ' +' + eq.weapon.bonusValue : '') + '</div>' +
          '</div>';
      } else {
        wSlot.className = 'gear-weapon';
        wSlot.innerHTML = '<span class="gw-icon">‚öîÔ∏è</span><div class="gw-info"><span class="gw-empty">Aucune arme</span></div>';
      }

      // Artifact slots
      const slotsEl = document.getElementById('gearSlots');
      let slotsHtml = '';
      for (const slot of GEAR_SLOT_DEFS) {
        const art = eq.artifacts[slot.id];
        if (art) {
          slotsHtml += '<div class="gear-slot equipped" onclick="openInventory(\'' + slot.id + '\')">' +
            '<span class="gs-icon">' + slot.icon + '</span>' +
            '<div class="gs-info">' +
            '<div class="gs-name" style="color:' + (art.tierColor || '#9ca3af') + '">' + art.tierLabel + '</div>' +
            '<div class="gs-stat">' + art.mainStat.label + ' +' + art.mainStat.value + '</div>' +
            '</div></div>';
        } else {
          slotsHtml += '<div class="gear-slot" onclick="openInventory(\'' + slot.id + '\')">' +
            '<span class="gs-icon">' + slot.icon + '</span>' +
            '<div class="gs-info"><span class="gs-empty">' + slot.name + '</span></div></div>';
        }
      }
      slotsEl.innerHTML = slotsHtml;

      // Summary
      const bonuses = getGearBonuses();
      const summaryEl = document.getElementById('gearSummary');
      let sumHtml = '';
      for (const [stat, val] of Object.entries(bonuses)) {
        if (val > 0) {
          const pct = stat.endsWith('_pct') ? '%' : '';
          sumHtml += '<span style="color:#a78bfa">' + STAT_LABELS[stat] + ' +' + val + pct + '</span>';
        }
      }
      // Show Manaya set count if any
      const mCount = countEquippedManayaPieces();
      if (mCount > 0) {
        sumHtml += '<span style="color:' + MANAYA_SET_COLOR + ';font-weight:bold">Set Manaya ' + mCount + '/9</span>';
      }
      summaryEl.innerHTML = sumHtml || '<span style="color:#555">Aucun bonus</span>';
    }

    let currentInvFilter = 'all';

    function openInventory(filter) {
      currentInvFilter = filter;
      const modal = document.getElementById('invModal');
      const titleEl = document.getElementById('invTitle');
      const itemsEl = document.getElementById('invItems');
      const inv = loadInventory();
      const eq = loadEquipped();

      if (filter === 'weapon') {
        titleEl.textContent = 'Armes';
      } else if (filter === 'all') {
        titleEl.textContent = 'Inventaire (' + inv.length + ' items)';
      } else {
        const slotDef = GEAR_SLOT_DEFS.find(s => s.id === filter);
        titleEl.textContent = slotDef ? slotDef.name : 'Inventaire';
      }

      // Filter items
      let filtered = inv;
      if (filter === 'weapon') {
        filtered = inv.filter(i => i.type === 'weapon');
      } else if (filter !== 'all') {
        filtered = inv.filter(i => i.slot === filter);
      }

      if (filtered.length === 0) {
        // Show equipped + unequip option if slot has gear
        let html = '<div class="inv-empty">Aucun item</div>';
        if (filter === 'weapon' && eq.weapon) {
          html = buildInvRow(eq.weapon, true);
        } else if (filter !== 'all' && filter !== 'weapon' && eq.artifacts[filter]) {
          html = buildInvRow(eq.artifacts[filter], true);
        }
        itemsEl.innerHTML = html;
      } else {
        // Show current equipped at top if applicable
        let html = '';
        if (filter === 'weapon' && eq.weapon) {
          html += '<div style="font-size:9px;color:#f59e0b;margin-bottom:4px">√âquip√©:</div>' + buildInvRow(eq.weapon, true);
          html += '<div style="font-size:9px;color:#94a3b8;margin:6px 0 4px">Inventaire:</div>';
        } else if (filter !== 'all' && filter !== 'weapon' && eq.artifacts[filter]) {
          html += '<div style="font-size:9px;color:#f59e0b;margin-bottom:4px">√âquip√©:</div>' + buildInvRow(eq.artifacts[filter], true);
          html += '<div style="font-size:9px;color:#94a3b8;margin:6px 0 4px">Inventaire:</div>';
        }
        for (const item of filtered) {
          html += buildInvRow(item, false);
        }
        itemsEl.innerHTML = html;
      }

      modal.style.display = 'block';
    }

    function buildInvRow(item, isEquipped) {
      const isWeapon = item.type === 'weapon';
      const icon = isWeapon ? (item.icon || '‚öîÔ∏è') : (GEAR_SLOT_DEFS.find(s => s.id === item.slot)?.icon || 'üì¶');
      const tierColor = item.tierColor || '#9ca3af';
      const name = item.name || (item.tierLabel + ' ' + (item.slotName || ''));
      const mainLine = isWeapon
        ? 'ATK +' + item.atk + (item.bonusStat ? ' | ' + STAT_LABELS[item.bonusStat] + ' +' + item.bonusValue : '')
        : item.mainStat ? item.mainStat.label + ' +' + item.mainStat.value : '';
      const subsLine = !isWeapon && item.subs ? item.subs.map(s => s.label + '+' + s.value).join(' ¬∑ ') : '';
      const tierLabel = item.tier ? '<span class="inv-tier" style="color:' + tierColor + '">' + item.tier + '</span> ' : '';

      let actions = '';
      if (isEquipped) {
        const slotArg = isWeapon ? 'weapon' : item.slot;
        actions = '<button onclick="event.stopPropagation();unequipItem(\'' + slotArg + '\');openInventory(\'' + currentInvFilter + '\')" class="danger">Retirer</button>';
      } else {
        actions = '<button onclick="event.stopPropagation();equipFromInv(\'' + item.id + '\')" class="success">√âquiper</button>' +
          '<button onclick="event.stopPropagation();trashItem(\'' + item.id + '\')" class="danger" title="D√©truire">üóëÔ∏è</button>';
      }

      return '<div class="inv-row">' +
        '<span class="inv-icon">' + icon + '</span>' +
        '<div class="inv-info">' +
        '<div class="inv-name">' + tierLabel + '<span style="color:' + tierColor + '">' + name + '</span></div>' +
        (mainLine ? '<div class="inv-main">' + mainLine + '</div>' : '') +
        (subsLine ? '<div class="inv-subs">' + subsLine + '</div>' : '') +
        '</div>' +
        '<div class="inv-actions">' + actions + '</div>' +
        '</div>';
    }

    function equipFromInv(itemId) {
      const inv = loadInventory();
      const item = inv.find(i => i.id === itemId);
      if (!item) return;
      equipItem(item);
      openInventory(currentInvFilter);
    }

    function trashItem(itemId) {
      removeFromInventory(itemId);
      openInventory(currentInvFilter);
    }

    function closeInventory() {
      document.getElementById('invModal').style.display = 'none';
    }

    // Initialize gear panel + forge
    updateGearPanel();
    updateForgePanel();

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function resize() {
      const gameDiv = document.getElementById('game');
      canvas.width = gameDiv.clientWidth;
      canvas.height = gameDiv.clientHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // ‚îÄ‚îÄ Connection ‚îÄ‚îÄ
    function connect() {
      const username = document.getElementById('username').value || 'Player';
      const host = location.hostname;
      const port = location.port || 3001;
      ws = new WebSocket('ws://' + host + ':' + port + '/ws?username=' + encodeURIComponent(username));
      ws.onopen = () => {
        log('Connected!', 'info');
        document.getElementById('status').textContent = 'Connected';
        // Hide connection section once connected
        document.getElementById('connectionSection').style.display = 'none';
        document.getElementById('btnCreate').disabled = false;
        document.getElementById('btnJoin').disabled = false;
        document.getElementById('btnBrowse').disabled = false;
        refreshRoomList(); // Auto-fetch room list on connect
        // Create profile on connect if doesn't exist, then sync to server
        const profile = getOrCreateProfile(username);
        if (profile) {
          ws.send(JSON.stringify({ type: 'save_profile', profile }));
        }
        updateProfileDisplay();
      };
      ws.onmessage = (e) => handleMessage(JSON.parse(e.data));
      ws.onclose = () => {
        log('Disconnected', 'error');
        document.getElementById('status').textContent = 'Disconnected';
        document.getElementById('connectionSection').style.display = 'block';
        document.getElementById('btnCreate').disabled = true;
        document.getElementById('btnJoin').disabled = true;
        document.getElementById('btnReady').disabled = true;
        document.getElementById('btnBrowse').disabled = true;
        document.getElementById('roomList').innerHTML = '';
        ws = null; myId = null; inRoom = false; gameState = null; roomInfo = null;
      };
    }
    function disconnect() { if (ws) ws.close(); }
    function send(msg) { if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(msg)); }

    // ‚îÄ‚îÄ Room Actions ‚îÄ‚îÄ
    function createRoom() { send({ type: 'create_room' }); }
    function joinRoom() { send({ type: 'join_room', code: document.getElementById('roomCode').value }); }
    function refreshRoomList() { send({ type: 'list_rooms' }); }
    function joinRoomByCode(code) { document.getElementById('roomCode').value = code; joinRoom(); }
    function selectClass() {
      const cls = document.getElementById('classSelect').value;
      if (cls && inRoom) { send({ type: 'select_class', class: cls }); log('Class: ' + CLASS_LABELS[cls], 'info'); }
    }
    function selectDifficulty() { if (inRoom) send({ type: 'select_difficulty', difficulty: document.getElementById('diffSelect').value }); }
    function toggleSimulation() {
      const enabled = document.getElementById('simToggle').checked;
      document.getElementById('simControls').style.display = enabled ? 'block' : 'none';
      if (inRoom) send({ type: 'set_simulation', enabled });
    }
    function simSetBossHp(pct) { send({ type: 'input', input: { type: 'sim_set_boss_hp', percent: pct } }); }
    function simFullHeal() { send({ type: 'input', input: { type: 'sim_full_heal' } }); }
    function simKillAdds() { send({ type: 'input', input: { type: 'sim_kill_adds' } }); }
    function simSpawnAdds() { send({ type: 'input', input: { type: 'sim_spawn_adds', adds: [{ type: 'minion' }, { type: 'elite' }] } }); }
    function selectHunters() {
      if (!inRoom) return;
      send({
        type: 'select_hunters',
        mainHunter: null,
        supportHunters: [...selectedHunters],
        hunterLevel: parseInt(document.getElementById('hunterLevel').value) || 30,
        hunterStars: 0,
      });
    }
    function toggleReady() {
      const cls = document.getElementById('classSelect').value;
      if (cls && inRoom) send({ type: 'select_class', class: cls });
      selectHunters();
      // Sync profile stats before ready
      syncProfileToServer();
      send({ type: 'player_ready' });
    }
    function syncProfileToServer() {
      const profile = loadProfile();
      if (!profile) return;
      const { allocated } = getStatPoints(profile);
      // Merge builderberu.com stat bonuses (from URL) with game server stat points
      const mergedStats = { ...allocated };
      if (autoStatPoints) {
        for (const [stat, val] of Object.entries(autoStatPoints)) {
          if (typeof val === 'number' && val > 0) mergedStats[stat] = (mergedStats[stat] || 0) + val;
        }
      }
      send({
        type: 'sync_profile',
        data: {
          level: profile.level,
          statPoints: mergedStats,
          equippedHunters: selectedHunters.filter(Boolean),
          raidGear: loadEquipped(),
        },
      });
    }
    function onJoinedRoom() {
      inRoom = true;
      document.getElementById('btnReady').disabled = false;
      const cls = document.getElementById('classSelect').value;
      if (cls) { send({ type: 'select_class', class: cls }); }
      selectHunters();
      syncProfileToServer();
      updateStatsPanel();
    }
    function updateRoomDisplay() {
      if (!roomInfo) { document.getElementById('roomPlayers').innerHTML = ''; return; }
      const profile = loadProfile();
      const html = roomInfo.players.map(p => {
        const cls = CLASS_LABELS[p.class] || '???';
        const readyCls = p.ready ? 'ready' : 'not-ready';
        const isMe = p.id === myId;
        const lvl = isMe && profile ? ' Lv.' + profile.level : '';
        const hunter = p.mainHunter ? (' [' + (HUNTER_LIST[p.mainHunter]?.name || p.mainHunter) + ']') : '';
        return '<div class="' + readyCls + '">' + p.username + (isMe ? ' *' : '') + lvl + ' - ' + cls + hunter + (p.ready ? ' \u2713' : '') + '</div>';
      }).join('');
      document.getElementById('roomPlayers').innerHTML = html;
    }

    // ‚îÄ‚îÄ Message Handler ‚îÄ‚îÄ
    function handleMessage(msg) {
      switch (msg.type) {
        case 'connected': myId = msg.id; log('ID: ' + myId, 'info'); break;
        case 'room_created':
          roomInfo = msg.room; document.getElementById('roomCode').value = msg.code;
          log('Room: ' + msg.code, 'info'); onJoinedRoom(); updateRoomDisplay(); break;
        case 'room_joined':
          roomInfo = msg.room; document.getElementById('roomCode').value = msg.room.code;
          log('Joined: ' + msg.room.code, 'info'); onJoinedRoom(); updateRoomDisplay(); break;
        case 'player_joined': log(msg.player.username + ' joined', 'info'); roomInfo = msg.room; updateRoomDisplay(); break;
        case 'player_left': log('Player left', 'info'); roomInfo = msg.room; updateRoomDisplay(); break;
        case 'class_selected': case 'difficulty_changed': case 'ready_changed': case 'hunters_selected':
          roomInfo = msg.room; updateRoomDisplay(); break;
        case 'countdown_start': case 'countdown_tick': log('Starting in ' + msg.seconds + '...', 'event'); break;
        case 'countdown_cancelled': log('Countdown cancelled', 'info'); break;

        case 'game_start':
          log('FIGHT!', 'event'); gameStartTime = Date.now();
          document.getElementById('bossHud').style.display = 'block';
          document.getElementById('dpsPanel').style.display = 'block';
          document.getElementById('hunterBar').style.display = 'flex';
          document.getElementById('skillBar').style.display = 'flex';
          document.getElementById('playerHud').style.display = 'block';
          document.getElementById('partyHud').style.display = 'flex';
          document.getElementById('versionTag').textContent = 'Manaya Raid ' + MANAYA_VERSION;
          // Start battle music
          battleMusic.currentTime = 0;
          battleMusic.play().catch(() => {});
          break;

        case 'state': gameState = msg; updateHUD(); break;

        // ‚îÄ‚îÄ Damage events ‚Üí floating numbers + particles + shake ‚îÄ‚îÄ
        case 'damage':
          if (msg.amount > 0 && gameState) {
            const boss = gameState.boss;
            if (msg.target && msg.target.startsWith('boss')) {
              addFloatingNumber(boss.x, boss.y, msg.amount, msg.crit, false);
              if (msg.crit) spawnParticles(boss.x, boss.y, '#ffd700', 6, 120, 4);
              else spawnParticles(boss.x, boss.y, '#fff', 3, 80, 3);
              playerAttackTimers[msg.source] = Date.now(); // Trigger attack anim
            } else if (msg.target && msg.target.startsWith('add_')) {
              // Damage TO add
              const add = (gameState.adds || []).find(a => a.id === msg.target);
              if (add) {
                addFloatingNumber(add.x, add.y, msg.amount, msg.crit, false);
                spawnParticles(add.x, add.y, '#ff6b6b', 4, 80, 3);
              }
              playerAttackTimers[msg.source] = Date.now();
            } else {
              const p = (gameState.players || []).find(pl => pl.id === msg.target);
              if (p) {
                addFloatingNumber(p.x, p.y, msg.amount, msg.crit, false);
                if (msg.amount > 2000) triggerScreenShake(Math.min(12, msg.amount / 500));
                spawnParticles(p.x, p.y, '#ef4444', 4, 100, 3);
              }
            }
            if (msg.source === myId) log((msg.skill || 'Hit') + ': ' + msg.amount + (msg.crit ? ' CRIT!' : ''), 'damage');
            else if (msg.target === myId) log((msg.skill || 'Hit') + ': -' + msg.amount, 'error');
          }
          break;

        case 'heal':
          if (msg.amount > 0 && gameState) {
            const p = (gameState.players || []).find(pl => pl.id === msg.target);
            if (p) addFloatingNumber(p.x, p.y, msg.amount, false, true);
          }
          log('Heal: +' + msg.amount, 'heal');
          break;

        case 'hunter_summon':
          if (gameState && gameState.boss) addFloatingNumber(gameState.boss.x, gameState.boss.y, msg.amount, msg.crit, false);
          log(msg.hunterName + ' - ' + msg.skillName + ': ' + msg.amount + (msg.crit ? ' CRIT!' : ''), 'hunter');
          break;

        case 'summon_failed': if (msg.player === myId) log('Summon: ' + msg.reason, 'error'); break;
        case 'dot_tick':
          if (gameState && msg.amount > 0) {
            const pt = (gameState.players || []).find(pl => pl.id === msg.target);
            if (pt) addFloatingNumber(pt.x, pt.y, msg.amount, false, false);
          }
          if (msg.target === myId) log('Poison x' + (msg.stacks || 1) + ': -' + msg.amount, 'error');
          break;
        case 'resurrect':
          log(msg.source === myId ? 'Vous avez ressuscit\u00e9 ' + (msg.target === myId ? 'vous-m\u00eame?!' : 'un alli\u00e9') :
              (msg.target === myId ? 'Vous avez \u00e9t\u00e9 ressuscit\u00e9 !' : 'Un alli\u00e9 a \u00e9t\u00e9 ressuscit\u00e9'), 'heal');
          if (msg.target === myId) {
            // Rez flash effect
            screenShake.intensity = 5;
          }
          break;
        case 'boss_message': log(msg.text, 'event'); break;
        case 'boss_curl':
          log('‚ö†Ô∏è Manaya se met en boule !', 'error');
          screenShake.intensity = 3;
          break;
        case 'boss_uncurl':
          log('üí• EXPLOSION !', 'error');
          screenShake.intensity = 15;
          playExplosionBoom();
          break;
        case 'warning_beep':
          playWarningBeep(msg.urgency || 0.5);
          break;
        case 'boss_enrage': log('BOSS ENRAGED!', 'error'); break;
        case 'boss_rage_stack': log(msg.message, 'error'); break;
        case 'phase_change': log('Phase ' + msg.phase, 'event'); break;
        case 'shield_activated': log('Shield: ' + Math.round(msg.shieldHp) + ' HP', 'event'); break;
        case 'shield_timer': log('Shield: ' + msg.remaining + 's left!', 'error'); break;
        case 'debuff_applied':
          if (msg.target === myId) log('‚ö™ MARQUE: ' + msg.name + ' appliqu√©e !', 'error');
          else log((gameState.players || []).find(p => p.id === msg.target)?.username + ' re√ßoit ' + msg.name, 'event');
          break;
        case 'debuff_removed':
          if (msg.target === myId) log('Marque retir√©e: ' + msg.debuff, 'info');
          break;
        case 'cleanse': log('Cleanse!', 'heal'); break;
        case 'add_spawn': log(msg.name + ' appeared!', 'error'); break;
        case 'add_killed': log('Add killed!', 'damage'); break;
        case 'simulation_changed': log('Simulation: ' + (msg.simulation ? 'ON' : 'OFF'), 'info'); break;

        case 'game_end': {
          // Fade out battle music
          const fadeOut = setInterval(() => {
            if (battleMusic.volume > 0.05) battleMusic.volume = Math.max(0, battleMusic.volume - 0.05);
            else { clearInterval(fadeOut); battleMusic.pause(); battleMusic.volume = 0.35; }
          }, 100);
          // Hide death overlay if showing
          document.getElementById('deathOverlay').style.display = 'none';
          document.getElementById('game').classList.remove('dead-filter');

          const victory = msg.result.victory;
          const clearTime = msg.result.time ? Math.floor(msg.result.time) : null;

          // Log as before
          if (victory) {
            log('VICTOIRE!' + (clearTime ? ' en ' + clearTime + 's' : ''), 'heal');
          } else {
            log('DEFAITE: ' + msg.result.reason, 'error');
          }

          // Apply XP
          let myXp = 0, profileAfter = null;
          if (msg.result.stats) {
            const myStats = msg.result.stats.find(s => s.id === myId);
            if (myStats && myStats.xpReward > 0) {
              const cls = document.getElementById('classSelect').value;
              profileAfter = addXpToProfile(myStats.xpReward, victory, cls, clearTime);
              myXp = myStats.xpReward;
              log('+' + myXp + ' XP !', 'heal');
            }
          }

          // ‚îÄ‚îÄ Show Game End Overlay ‚îÄ‚îÄ
          const overlay = document.getElementById('gameEndOverlay');
          const titleEl = document.getElementById('gameEndTitle');
          const subtitleEl = document.getElementById('gameEndSubtitle');
          const tbody = document.getElementById('gameEndStatsBody');
          const xpAmountEl = document.getElementById('gameEndXpAmount');
          const xpBarFillEl = document.getElementById('gameEndXpBarFill');
          const levelInfoEl = document.getElementById('gameEndLevelInfo');
          const timerEl = document.getElementById('gameEndTimer');

          titleEl.textContent = victory ? 'VICTOIRE' : 'DEFAITE';
          titleEl.className = 'game-end-title ' + (victory ? 'victory' : 'defeat');

          if (victory && clearTime) {
            const min = Math.floor(clearTime / 60);
            const sec = clearTime % 60;
            subtitleEl.textContent = 'Manaya vaincue en ' + (min > 0 ? min + 'min ' : '') + sec + 's';
          } else if (!victory) {
            const reasons = { party_wipe: 'Toute l\'√©quipe est tomb√©e', enrage_timer: 'Temps √©coul√©' };
            subtitleEl.textContent = reasons[msg.result.reason] || msg.result.reason;
          } else {
            subtitleEl.textContent = '';
          }

          // Stats table
          tbody.innerHTML = '';
          if (msg.result.stats) {
            // Sort by damage dealt (descending)
            const sorted = [...msg.result.stats].sort((a, b) => b.damageDealt - a.damageDealt);
            for (const s of sorted) {
              const isMe = s.id === myId;
              const classColors = { tank: '#3b82f6', healer: '#10b981', dps_cac: '#ef4444', dps_range: '#f59e0b' };
              const tr = document.createElement('tr');
              if (isMe) tr.className = 'me';
              tr.innerHTML =
                '<td>' + (isMe ? '\u2b50 ' : '') + s.username + '</td>' +
                '<td style="color:' + (classColors[s.class] || '#888') + '">' + (CLASS_LABELS[s.class] || '?') + '</td>' +
                '<td style="color:#f97316">' + formatNum(s.damageDealt) + '</td>' +
                '<td style="color:#10b981">' + formatNum(s.healingDone) + '</td>' +
                '<td style="color:#ef4444">' + formatNum(s.damageTaken) + '</td>' +
                '<td>' + s.deaths + '</td>' +
                '<td style="color:#a78bfa;font-weight:bold">+' + (s.xpReward || 0) + '</td>';
              tbody.appendChild(tr);
            }
          }

          // XP section
          xpAmountEl.textContent = '+' + myXp + ' XP';
          if (profileAfter) {
            const needed = xpForLevel(profileAfter.level + 1);
            const xpPct = needed > 0 ? Math.min(100, (profileAfter.xp / needed) * 100) : 100;
            levelInfoEl.textContent = 'Niveau ' + profileAfter.level + ' ‚Äî ' + profileAfter.xp + ' / ' + needed + ' XP';
            xpBarFillEl.style.width = xpPct + '%';
          } else {
            levelInfoEl.textContent = myXp > 0 ? '' : 'Simulation ‚Äî Pas d\'XP';
            xpBarFillEl.style.width = '0%';
          }

          // ‚îÄ‚îÄ Loot Drops ‚îÄ‚îÄ
          const lootSection = document.getElementById('gameEndLoot');
          const lootItemsEl = document.getElementById('gameEndLootItems');
          if (victory && msg.result.loot) {
            const myLoot = msg.result.loot.find(l => l.playerId === myId);
            const hasItems = myLoot && myLoot.items.length > 0;
            const hasFeathers = myLoot && myLoot.feathers > 0;

            if (hasItems || hasFeathers) {
              // Add items to inventory
              if (hasItems) addToInventory(myLoot.items);
              // Add feathers
              if (hasFeathers) {
                addFeathers(myLoot.feathers);
                log('ü™∂ +' + myLoot.feathers + ' Plume de Manaya !', 'hunter');
              }
              updateGearPanel();
              updateForgePanel();

              lootItemsEl.innerHTML = '';

              // Show feather drop first (rare!)
              if (hasFeathers) {
                const fDiv = document.createElement('div');
                fDiv.className = 'loot-item';
                fDiv.style.borderColor = MANAYA_SET_COLOR;
                fDiv.style.background = 'rgba(255,45,85,0.15)';
                fDiv.innerHTML =
                  '<div class="loot-icon" style="font-size:24px">ü™∂</div>' +
                  '<div class="loot-name" style="color:' + MANAYA_SET_COLOR + ';font-weight:bold">Plume de Manaya</div>' +
                  '<div class="loot-main" style="color:#f59e0b">x' + myLoot.feathers + '</div>' +
                  '<div class="loot-tier" style="color:' + MANAYA_SET_COLOR + '">RARE</div>';
                lootItemsEl.appendChild(fDiv);
              }

              // Show item drops
              for (const item of (myLoot.items || [])) {
                const isWeapon = item.type === 'weapon';
                const icon = isWeapon ? (item.icon || '‚öîÔ∏è') : (GEAR_SLOT_DEFS.find(s => s.id === item.slot)?.icon || 'üì¶');
                const tierColor = item.tierColor || '#9ca3af';
                const name = isWeapon ? item.name : (item.tierLabel + ' ' + (item.slotName || ''));
                const mainLine = isWeapon
                  ? 'ATK +' + item.atk
                  : item.mainStat ? item.mainStat.label + ' +' + item.mainStat.value : '';

                const div = document.createElement('div');
                div.className = 'loot-item';
                div.style.borderColor = tierColor;
                div.innerHTML =
                  '<div class="loot-icon">' + icon + '</div>' +
                  '<div class="loot-name" style="color:' + tierColor + '">' + name + '</div>' +
                  '<div class="loot-main">' + mainLine + '</div>' +
                  '<div class="loot-tier" style="color:' + tierColor + '">' + (item.tier || '') + '</div>';
                lootItemsEl.appendChild(div);
              }
              lootSection.style.display = 'block';
              if (hasItems) log(myLoot.items.length + ' item(s) obtenu(s) !', 'heal');
            } else {
              lootSection.style.display = 'none';
            }
          } else {
            lootSection.style.display = 'none';
          }

          // Countdown timer (room resets in 10s)
          let countdown = 10;
          timerEl.textContent = 'Retour au lobby dans ' + countdown + 's...';
          const countdownInterval = setInterval(() => {
            countdown--;
            if (countdown <= 0) {
              clearInterval(countdownInterval);
              timerEl.textContent = 'Retour au lobby...';
            } else {
              timerEl.textContent = 'Retour au lobby dans ' + countdown + 's...';
            }
          }, 1000);

          overlay.style.display = 'block';
          break;
        }

        case 'room_reset':
          roomInfo = msg.room; gameState = null; floatingNumbers = [];
          document.getElementById('bossHud').style.display = 'none';
          document.getElementById('dpsPanel').style.display = 'none';
          document.getElementById('hunterBar').style.display = 'none';
          document.getElementById('skillBar').style.display = 'none';
          document.getElementById('playerHud').style.display = 'none';
          document.getElementById('buffDisplay').innerHTML = '';
          document.getElementById('gameEndOverlay').style.display = 'none';
          document.getElementById('deathOverlay').style.display = 'none';
          document.getElementById('game').classList.remove('dead-filter');
          updateRoomDisplay();
          updateGearPanel();
          updateForgePanel();
          log('Room reset ‚Äî Pr√™t pour un nouveau combat !', 'info');
          break;

        case 'events_batch':
          for (const evt of msg.events) handleMessage(evt);
          break;

        case 'room_list':
          renderRoomList(msg.rooms);
          break;

        case 'error': log('Error: ' + msg.message, 'error'); break;
      }
    }

    function renderRoomList(rooms) {
      const el = document.getElementById('roomList');
      if (!rooms || rooms.length === 0) {
        el.innerHTML = '<div style="font-size:10px;color:#666;padding:4px;text-align:center">No rooms available. Create one!</div>';
        return;
      }
      let html = '';
      for (const r of rooms) {
        const stateColors = { waiting: '#10b981', countdown: '#f59e0b', playing: '#ef4444', finished: '#6b7280' };
        const stateLabels = { waiting: 'Waiting', countdown: 'Starting...', playing: 'In Game', finished: 'Ended' };
        const canJoin = r.state === 'waiting' && r.playerCount < r.maxPlayers;
        const playerList = r.players.map(p => (CLASS_LABELS[p.class] || '?')).join(', ');
        html += '<div style="background:#1a1a2e;border:1px solid #333;border-radius:4px;padding:5px;margin-bottom:3px;font-size:10px">' +
          '<div style="display:flex;justify-content:space-between;align-items:center">' +
          '<span style="font-weight:bold;color:#a78bfa">' + r.code + '</span>' +
          '<span style="color:' + (stateColors[r.state] || '#888') + ';font-size:9px">' + (stateLabels[r.state] || r.state) + '</span>' +
          '</div>' +
          '<div style="color:#888;font-size:9px">' + r.host + ' | ' + r.difficulty + ' | ' + r.playerCount + '/' + r.maxPlayers + '</div>' +
          '<div style="color:#666;font-size:9px">' + (playerList || 'No class selected') + '</div>' +
          (canJoin ? '<button onclick="joinRoomByCode(\'' + r.code + '\')" style="margin-top:3px;font-size:9px;padding:2px 8px;background:#10b981">Join</button>' : '') +
          '</div>';
      }
      el.innerHTML = html;
    }

    // ‚îÄ‚îÄ HUD Updates ‚îÄ‚îÄ
    function updateHUD() {
      if (!gameState) return;
      const boss = gameState.boss;
      const me = gameState.players.find(p => p.id === myId);

      // ‚îÄ‚îÄ Boss HP Bar ‚îÄ‚îÄ
      if (boss) {
        const hpPerBar = boss.maxHp / HP_BARS;
        const currentBar = Math.max(0, Math.ceil(boss.hp / hpPerBar));
        const remainder = boss.hp % hpPerBar;
        const barProgress = currentBar > 0 ? (remainder === 0 && boss.hp > 0 ? 1 : remainder / hpPerBar) : 0;
        const colorIdx = (currentBar - 1) % BAR_COLORS.length;
        const color = currentBar > 0 ? BAR_COLORS[Math.max(0, colorIdx)] : '#333';
        const nextColor = currentBar > 1 ? BAR_COLORS[(currentBar - 2) % BAR_COLORS.length] : '#111';

        let nameText = boss.enraged ? 'MANAYA ENRAGED' : 'MANAYA';
        nameText += ' - Phase ' + boss.phase;
        if (boss.speedStacks > 0) nameText += ' \u26A1x' + boss.speedStacks;
        document.getElementById('bossName').textContent = nameText;
        document.getElementById('bossName').style.color = boss.enraged ? '#ff4444' : '#ef4444';
        document.getElementById('bossBg').style.background = nextColor;
        document.getElementById('bossFill').style.width = (barProgress * 100) + '%';
        document.getElementById('bossFill').style.background = color;
        document.getElementById('bossText').textContent = currentBar + ' / ' + HP_BARS;
        const hpPctBoss = boss.maxHp > 0 ? ((boss.hp / boss.maxHp) * 100).toFixed(1) : '0.0';
        document.getElementById('bossInfo').textContent = hpPctBoss + '% ‚Äî ' + Math.round(boss.hp).toLocaleString() + ' / ' + Math.round(boss.maxHp).toLocaleString() + ' HP';

        const shieldBarEl = document.getElementById('shieldBar');
        if (boss.shielded) {
          shieldBarEl.style.display = 'block';
          document.getElementById('shieldFill').style.width = ((boss.shieldHp / boss.shieldMaxHp) * 100) + '%';
        } else { shieldBarEl.style.display = 'none'; }

        // Rage buff indicator
        const rageEl = document.getElementById('bossRageInfo');
        if (boss.rageBuff > 0) {
          rageEl.textContent = '\u{1F525} RAGE x' + boss.rageBuff + (boss.rageBuff >= 3 ? ' ‚Äî DMG \u00D73!' : ' ‚Äî DISPEL!');
          rageEl.style.color = boss.rageBuff >= 3 ? '#ff4444' : '#f97316';
        } else { rageEl.textContent = ''; }
      }

      // ‚îÄ‚îÄ Timer ‚îÄ‚îÄ
      if (gameState.timer !== undefined) {
        const totalSec = Math.max(0, gameState.timer);
        const min = Math.floor(totalSec / 60);
        const sec = Math.floor(totalSec % 60);
        const timerEl = document.getElementById('gameTimer');
        timerEl.textContent = min + ':' + String(sec).padStart(2, '0');
        timerEl.style.color = totalSec < 60 ? '#ef4444' : '#ccc';
      }

      // ‚îÄ‚îÄ Player HP/Mana/Endurance Bar (bottom) ‚îÄ‚îÄ
      if (me) {
        const hpPct = me.alive ? (me.hp / me.maxHp) : 0;
        const hpColor = hpPct > 0.5 ? '#10b981' : hpPct > 0.25 ? '#f59e0b' : '#ef4444';
        document.getElementById('playerHpFill').style.width = (hpPct * 100) + '%';
        document.getElementById('playerHpFill').style.background = hpColor;
        document.getElementById('playerHpText').textContent = Math.round(me.hp) + ' / ' + me.maxHp;
        const isRage = me.useRage;
        const manaPct = (me.mana / me.maxMana) * 100;
        document.getElementById('playerManaFill').style.width = manaPct + '%';
        document.getElementById('playerManaFill').style.background = isRage ? '#ef4444' : '#3b82f6';
        document.getElementById('playerManaText').textContent = (isRage ? 'RAGE ' : '') + Math.round(me.mana) + ' / ' + me.maxMana;
        const mainH = me.mainHunter ? HUNTER_LIST[me.mainHunter]?.name : null;
        document.getElementById('playerHudName').textContent = (mainH || me.username || 'YOU') + ' [' + (CLASS_LABELS[me.class] || '?') + ']';

        // Tank endurance bar
        const enduranceOuter = document.getElementById('playerEnduranceOuter');
        if (me.maxEndurance > 0) {
          enduranceOuter.style.display = 'block';
          const endPct = (me.endurance / me.maxEndurance) * 100;
          const endColor = endPct > 50 ? 'linear-gradient(90deg, #f59e0b, #eab308)' :
                           endPct > 20 ? 'linear-gradient(90deg, #ea580c, #f59e0b)' :
                           'linear-gradient(90deg, #ef4444, #ea580c)';
          document.getElementById('playerEnduranceFill').style.width = endPct + '%';
          document.getElementById('playerEnduranceFill').style.background = endColor;
          document.getElementById('playerEnduranceText').textContent = Math.round(me.endurance) + ' / ' + me.maxEndurance + ' END';
        } else {
          enduranceOuter.style.display = 'none';
        }

        // ‚îÄ‚îÄ Death Overlay ‚îÄ‚îÄ
        const gameDiv = document.getElementById('game');
        const deathOverlay = document.getElementById('deathOverlay');
        if (!me.alive) {
          gameDiv.classList.add('dead-filter');
          deathOverlay.style.display = 'block';
          // Check if a healer is alive for rez hope
          const healerAlive = gameState.players.some(p => p.class === 'healer' && p.alive && p.id !== myId);
          const rezMsg = document.getElementById('deathRezMsg');
          if (healerAlive) {
            rezMsg.innerHTML = '<span style="color:#10b981">Un Healer est en vie !</span><br>En attente de R\u00e9surrection Divine...';
          } else {
            rezMsg.innerHTML = '<span style="color:#ef4444">Aucun Healer en vie...</span>';
          }
        } else {
          gameDiv.classList.remove('dead-filter');
          deathOverlay.style.display = 'none';
        }
      }

      // ‚îÄ‚îÄ DPS Meter ‚îÄ‚îÄ
      if (gameState.players) {
        const elapsed = Math.max(1, (Date.now() - gameStartTime) / 1000);
        const sorted = [...gameState.players].filter(p => p.stats).sort((a, b) => b.stats.damageDealt - a.stats.damageDealt);
        const maxDmg = sorted.length > 0 ? Math.max(1, sorted[0].stats.damageDealt) : 1;
        let dpsHtml = '';
        for (const p of sorted) {
          const dps = Math.round(p.stats.damageDealt / elapsed);
          const pct = (p.stats.damageDealt / maxDmg) * 100;
          const color = CLASS_COLORS[p.class] || '#888';
          const isMe = p.id === myId;
          const name = p.username || (isMe ? 'YOU' : p.id.substring(0, 5));
          dpsHtml += '<div class="dps-row"><div class="dps-color" style="background:' + color + '"></div>' +
            '<div class="dps-name">' + (isMe ? '* ' : '') + name + '</div>' +
            '<div class="dps-bar-bg"><div class="dps-bar-fill" style="width:' + pct + '%;background:' + color + '"></div></div>' +
            '<div class="dps-val">' + formatNum(dps) + '</div></div>';
        }
        if (me && me.stats) {
          dpsHtml += '<div style="margin-top:5px;border-top:1px solid #333;padding-top:4px;font-size:11px;color:#999">' +
            'Total DMG: ' + formatNum(me.stats.damageDealt) + '<br>' +
            'Heal: ' + formatNum(me.stats.healingDone) + ' | Deaths: ' + me.stats.deaths + '</div>';
        }
        document.getElementById('dpsContent').innerHTML = dpsHtml;
      }

      if (me) {
        updateSkillBar(me);
        updateHunterBar(me);
        updateBuffDisplay(me);
      }
      updatePartyHud();
    }

    function updateSkillBar(me) {
      const skillKeys = ['basic', 'secondary', 'skillA', 'skillB', 'ultimate'];
      const keyLabels = ['LMB', 'RMB', 'A', 'E', 'R'];
      const skills = skillKeys.map((sk, i) => ({
        key: keyLabels[i],
        cd: me.cooldowns?.[sk] || 0,
        maxCd: me.skills?.[sk]?.cooldown || 1,
        name: me.skills?.[sk]?.name || sk,
        manaCost: me.skills?.[sk]?.manaCost || 0,
      }));
      // Add dodge
      skills.push({ key: 'SPC', cd: me.dodgeCooldown || 0, maxCd: 3, name: 'Esquive', manaCost: 0 });

      let html = '';
      for (let i = 0; i < skills.length; i++) {
        const s = skills[i];
        const onCd = s.cd > 0.05;
        const hasMana = me.mana >= s.manaCost;
        const cdPct = onCd ? Math.min(100, (s.cd / Math.max(s.maxCd, s.cd)) * 100) : 0;
        // State class: on cd = default dark, ready = yellow glow, no mana = grayed
        let stateClass = '';
        if (onCd) stateClass = '';
        else if (!hasMana && s.manaCost > 0) stateClass = ' no-mana';
        else stateClass = ' ready';

        const rscLabel = me.useRage ? 'RG' : 'MP';
        const rscColor = me.useRage ? (hasMana ? '#ef4444' : '#991b1b') : (hasMana ? '#3b82f6' : '#ef4444');
        const manaText = s.manaCost > 0 ? '<span style="font-size:7px;color:' + rscColor + '">' + s.manaCost + ' ' + rscLabel + '</span>' : '';
        html += '<div class="skill-slot' + stateClass + '">' +
          '<span class="key-label">' + s.key + '</span>' +
          '<span class="skill-name">' + s.name + '</span>' + manaText +
          (onCd ? '<div class="cd-overlay" style="height:' + cdPct + '%"></div><span class="cd-text">' + s.cd.toFixed(1) + '</span>' : '') +
          '</div>';
        if (i === 1 || i === 4) html += '<div class="skill-sep"></div>';
      }
      document.getElementById('skillBar').innerHTML = html;
    }

    function updateHunterBar(me) {
      const hunters = me.supportHunters || [null, null, null];
      const cds = me.hunterCooldowns || [0, 0, 0];
      let html = '';
      for (let i = 0; i < 3; i++) {
        const hId = hunters[i];
        const hInfo = hId ? HUNTER_LIST[hId] : null;
        const hName = hInfo ? hInfo.name.split(' ').pop() : '---';
        const cd = cds[i] || 0;
        const onCd = cd > 0;
        const icon = hInfo ? (ELEMENT_ICONS[hInfo.element] || '') : '';
        html += '<div class="hunter-slot' + (onCd ? ' on-cd' : '') + '">' +
          '<span class="h-key">' + (i + 1) + '</span>' +
          (onCd ? '<span class="h-cd">' + Math.ceil(cd) + '</span>' :
            '<span class="h-name">' + icon + '<br>' + hName + '</span>') +
          '</div>';
      }
      document.getElementById('hunterBar').innerHTML = html;
    }

    function updateBuffDisplay(me) {
      if (!me.buffs || me.buffs.length === 0) { document.getElementById('buffDisplay').innerHTML = ''; return; }
      const BUFF_ICONS = {
        poison: { icon: '\u2620', neg: true, color: '#10b981', label: 'Poison' },
        atk_up: { icon: '\u2694', neg: false, color: '#ef4444', label: 'ATK+' },
        shield: { icon: '\u{1F6E1}', neg: false, color: '#38bdf8', label: 'Shield' },
        speed_up: { icon: '\u26A1', neg: false, color: '#f59e0b', label: 'SPD+' },
        speed_down: { icon: '\u{1F422}', neg: true, color: '#6b7280', label: 'Slow' },
      };
      let html = '';
      for (const b of me.buffs) {
        const info = BUFF_ICONS[b.type] || { icon: '?', neg: true, color: '#888', label: b.type };
        const isPoison = b.type === 'poison';
        // Poison: pulsing red border when high stacks
        const pulseStyle = isPoison && b.stacks >= 3 ? 'animation:pulse 0.5s ease-in-out infinite;' : '';
        const borderStyle = isPoison ? 'border-color:' + (b.stacks >= 5 ? '#ff0000' : b.stacks >= 3 ? '#f97316' : '#10b981') + ';' : '';
        html += '<div class="buff-icon ' + (info.neg ? 'negative' : 'positive') + '" style="' + pulseStyle + borderStyle + '">' +
          '<span style="font-size:16px">' + info.icon + '</span>' +
          '<span class="buff-dur">' + parseFloat(b.dur).toFixed(0) + '</span>' +
          (b.stacks > 1 ? '<span class="buff-stacks" style="background:' + (isPoison ? (b.stacks >= 5 ? '#ff0000' : '#f97316') : '#7c3aed') + '">' + b.stacks + '</span>' : '') +
          '</div>';
      }
      document.getElementById('buffDisplay').innerHTML = html;
    }

    function updatePartyHud() {
      if (!gameState || !gameState.players) return;
      const classIcon = { tank: '\u{1F6E1}', healer: '\u{1F49A}', dps_cac: '\u2694\uFE0F', dps_range: '\u{1F3AF}' };
      const BUFF_ICONS = {
        poison: '\u2620', atk_up: '\u2694', shield: '\u{1F6E1}', speed_up: '\u26A1', speed_down: '\u{1F422}',
        invuln: '\u2728', taunt: '\u{1F4E2}', def_up: '\u{1F6E1}',
        manaya_mark_D1: '\u2460', manaya_mark_D2: '\u2461', manaya_mark_D3: '\u2462',
      };
      const BUFF_CUSTOM_COLORS = {
        manaya_mark_D1: '#8BA02A', manaya_mark_D2: '#A855F7', manaya_mark_D3: '#EC64A4',
      };
      let html = '';
      for (const p of gameState.players) {
        const isMe = p.id === myId;
        const hpPct = p.alive ? (p.hp / p.maxHp) : 0;
        const hpColor = hpPct > 0.5 ? '#10b981' : hpPct > 0.25 ? '#f59e0b' : '#ef4444';
        const manaPct = p.maxMana > 0 ? (p.mana / p.maxMana) * 100 : 0;
        const mainH = p.mainHunter ? HUNTER_LIST[p.mainHunter]?.name : null;
        const name = mainH || p.username || (isMe ? 'YOU' : p.id.substring(0, 5));

        // Buffs/debuffs mini icons
        let buffsHtml = '';
        if (p.buffs && p.buffs.length > 0) {
          for (const b of p.buffs) {
            const icon = BUFF_ICONS[b.type] || '?';
            const isNeg = b.type === 'poison' || b.type === 'speed_down' || b.type.startsWith('debuff_') || b.type.startsWith('manaya_mark_');
            const customCol = BUFF_CUSTOM_COLORS[b.type];
            const style = customCol ? 'background:' + customCol + '33;border:1px solid ' + customCol + ';color:' + customCol : '';
            buffsHtml += '<div class="pm-buff ' + (customCol ? '' : (isNeg ? 'neg' : 'pos')) + '" title="' + b.type + (b.stacks > 1 ? ' x' + b.stacks : '') + '" style="' + style + '">' + icon + '</div>';
          }
        }

        html += '<div class="party-member' + (!p.alive ? ' dead' : '') + (isMe ? ' is-me' : '') + '">' +
          '<div class="pm-class-icon">' + (classIcon[p.class] || '?') + '</div>' +
          '<div class="pm-info">' +
          '<div class="pm-name">' + name + '</div>' +
          '<div class="pm-hp-outer"><div class="pm-hp-fill" style="width:' + (hpPct * 100) + '%;background:' + hpColor + '"></div>' +
          '<div class="pm-hp-text">' + Math.round(p.hp) + ' / ' + p.maxHp + '</div></div>' +
          '<div class="pm-mana-outer"><div class="pm-mana-fill" style="width:' + manaPct + '%;background:' + (p.useRage ? '#ef4444' : '#3b82f6') + '"></div></div>' +
          (buffsHtml ? '<div class="pm-buffs">' + buffsHtml + '</div>' : '') +
          '</div></div>';
      }
      document.getElementById('partyHud').innerHTML = html;
    }

    function formatNum(n) {
      if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
      if (n >= 1000) return (n / 1000).toFixed(1) + 'K';
      return Math.round(n).toString();
    }

    // ‚îÄ‚îÄ Input ‚îÄ‚îÄ
    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
      const key = e.key.toLowerCase();
      keys[key] = true;
      if (['z','q','s','d','arrowup','arrowleft','arrowdown','arrowright'].includes(key)) { e.preventDefault(); sendMovement(); }
      if (e.key === ' ') {
        e.preventDefault();
        // Dodge in ZQSD direction; if no direction, dodge backwards (opposite mouse)
        let dx = 0, dy = 0;
        if (keys['z'] || keys['arrowup']) dy -= 1;
        if (keys['s'] || keys['arrowdown']) dy += 1;
        if (keys['q'] || keys['arrowleft']) dx -= 1;
        if (keys['d'] || keys['arrowright']) dx += 1;
        const dodgeAngle = (dx !== 0 || dy !== 0) ? Math.atan2(dy, dx) : mouseAngle + Math.PI;
        send({ type: 'input', input: { type: 'dodge', angle: dodgeAngle } });
      }
      if (key === 'a') send({ type: 'input', input: { type: 'skill', skill: 'skillA', angle: mouseAngle } });
      if (key === 'e') send({ type: 'input', input: { type: 'skill', skill: 'skillB', angle: mouseAngle } });
      if (key === 'r') send({ type: 'input', input: { type: 'skill', skill: 'ultimate', angle: mouseAngle } });
      if (key === '1') send({ type: 'input', input: { type: 'summon', slot: 0 } });
      if (key === '2') send({ type: 'input', input: { type: 'summon', slot: 1 } });
      if (key === '3') send({ type: 'input', input: { type: 'summon', slot: 2 } });
    });
    document.addEventListener('keyup', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
      keys[e.key.toLowerCase()] = false; sendMovement();
    });
    canvas.addEventListener('mousemove', (e) => {
      if (!gameState || !myId) return;
      const me = gameState.players.find(p => p.id === myId);
      if (!me) return;
      const scale = Math.min(canvas.width / 1600, canvas.height / 1200);
      const offsetX = (canvas.width - 1600 * scale) / 2;
      const offsetY = (canvas.height - 1200 * scale) / 2;
      mouseAngle = Math.atan2((e.offsetY - offsetY) / scale - me.y, (e.offsetX - offsetX) / scale - me.x);
      const now = Date.now();
      if (now - lastAimSent > 100) { send({ type: 'input', input: { type: 'aim', angle: mouseAngle } }); lastAimSent = now; }
    });
    canvas.addEventListener('mousedown', (e) => {
      e.preventDefault();
      if (e.button === 0) {
        // Hold left click = start auto-attack combo
        send({ type: 'input', input: { type: 'start_basic', angle: mouseAngle } });
      } else if (e.button === 2) {
        send({ type: 'input', input: { type: 'attack_secondary', angle: mouseAngle } });
      }
    });
    canvas.addEventListener('mouseup', (e) => {
      if (e.button === 0) {
        // Release left click = stop auto-attack combo
        send({ type: 'input', input: { type: 'stop_basic' } });
      } else if (e.button === 2) {
        send({ type: 'input', input: { type: 'stop_secondary' } });
      }
    });
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    function sendMovement() {
      let x = 0, y = 0;
      if (keys['z'] || keys['arrowup']) y -= 1;
      if (keys['s'] || keys['arrowdown']) y += 1;
      if (keys['q'] || keys['arrowleft']) x -= 1;
      if (keys['d'] || keys['arrowright']) x += 1;
      if (x === 0 && y === 0) send({ type: 'input', input: { type: 'stop' } });
      else send({ type: 'input', input: { type: 'move', x, y } });
    }

    // ‚îÄ‚îÄ Canvas Rendering ‚îÄ‚îÄ
    let lastFrameTime = Date.now();

    function render() {
      const now = Date.now();
      const frameDt = (now - lastFrameTime) / 1000;
      lastFrameTime = now;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (!gameState) {
        ctx.fillStyle = '#888'; ctx.font = '18px Segoe UI'; ctx.textAlign = 'center';
        if (roomInfo) {
          ctx.fillText('Room: ' + roomInfo.code + ' (' + roomInfo.players.length + ' players)', canvas.width/2, canvas.height/2 - 80);
          ctx.font = '14px Segoe UI';
          roomInfo.players.forEach((p, i) => {
            ctx.fillStyle = p.ready ? '#10b981' : '#888';
            ctx.fillText(p.username + ' [' + (CLASS_LABELS[p.class] || '???') + ']' + (p.ready ? ' READY' : ''), canvas.width/2, canvas.height/2 - 40 + i * 30);
          });
        } else if (myId) { ctx.fillText('Create or join a room', canvas.width/2, canvas.height/2); }
        else { ctx.fillText('Click "Connect" to start', canvas.width/2, canvas.height/2); }
        requestAnimationFrame(render); return;
      }

      // ‚îÄ‚îÄ Screen Shake ‚îÄ‚îÄ
      if (screenShake.intensity > 0.5) {
        screenShake.x = (Math.random() - 0.5) * screenShake.intensity * 2;
        screenShake.y = (Math.random() - 0.5) * screenShake.intensity * 2;
        screenShake.intensity *= screenShake.decay;
      } else {
        screenShake.x = 0; screenShake.y = 0; screenShake.intensity = 0;
      }

      const scale = Math.min(canvas.width / 1600, canvas.height / 1200);
      const ox = (canvas.width - 1600 * scale) / 2 + screenShake.x;
      const oy = (canvas.height - 1200 * scale) / 2 + screenShake.y;
      ctx.save(); ctx.translate(ox, oy); ctx.scale(scale, scale);

      // Arena (map background)
      if (arenaMapLoaded) {
        ctx.drawImage(arenaMapImg, 0, 0, 1600, 1200);
        // Darken slightly for better visibility
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(0, 0, 1600, 1200);
      } else {
        ctx.fillStyle = '#12121e'; ctx.fillRect(0, 0, 1600, 1200);
        ctx.strokeStyle = '#1a1a30'; ctx.lineWidth = 1;
        for (let x = 0; x < 1600; x += 100) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, 1200); ctx.stroke(); }
        for (let y = 0; y < 1200; y += 100) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(1600, y); ctx.stroke(); }
      }
      // Arena border
      ctx.strokeStyle = '#2a2a4e'; ctx.lineWidth = 3; ctx.strokeRect(20, 20, 1560, 1160);

      // AoE Zones
      for (const zone of (gameState.aoeZones || [])) drawAoeZone(zone);

      // Projectiles with trails/glow
      for (const proj of (gameState.projectiles || [])) {
        ctx.save();
        const isBoss = proj.type === 'boss_projectile';
        const pColor = isBoss ? '#ef4444' : '#a78bfa';
        // Outer glow
        const glowGrad = ctx.createRadialGradient(proj.x, proj.y, 0, proj.x, proj.y, (proj.radius || 6) * 2.5);
        glowGrad.addColorStop(0, pColor + '66');
        glowGrad.addColorStop(1, pColor + '00');
        ctx.fillStyle = glowGrad;
        ctx.beginPath(); ctx.arc(proj.x, proj.y, (proj.radius || 6) * 2.5, 0, Math.PI * 2); ctx.fill();
        // Core
        ctx.fillStyle = pColor;
        ctx.shadowColor = pColor; ctx.shadowBlur = 12;
        ctx.beginPath(); ctx.arc(proj.x, proj.y, proj.radius || 6, 0, Math.PI * 2); ctx.fill();
        // Bright center
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(proj.x, proj.y, (proj.radius || 6) * 0.4, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
      }

      // Boss
      if (gameState.boss && gameState.boss.hp > 0) drawBoss(gameState.boss);

      // Adds
      for (const add of (gameState.adds || [])) drawAdd(add);

      // Players
      for (const p of (gameState.players || [])) drawPlayer(p);

      // Particles
      drawParticles(frameDt);

      // Aggro meters
      drawAggroMeters();
      // Floating damage numbers
      drawFloatingNumbers(frameDt);

      // Simulation indicator
      if (gameState.simulation) {
        ctx.save();
        ctx.fillStyle = 'rgba(245,158,11,0.15)';
        ctx.fillRect(0, 0, 1600, 40);
        ctx.fillStyle = '#f59e0b'; ctx.font = 'bold 20px sans-serif'; ctx.textAlign = 'center';
        ctx.fillText('SIMULATION MODE - GOD MODE ACTIVE', 800, 28);
        ctx.restore();
      }

      ctx.restore();
      requestAnimationFrame(render);
    }

    function drawAoeZone(zone) {
      const progress = 1 - (parseFloat(zone.ttl) / zone.maxTtl);

      if (zone.type === 'cone_telegraph') {
        // Draw actual cone/sector shape
        const alpha = 0.12 + progress * 0.35;
        const halfCone = (zone.coneAngle || Math.PI / 2) / 2;
        ctx.fillStyle = 'rgba(239,68,68,' + alpha + ')';
        ctx.strokeStyle = 'rgba(239,68,68,' + (0.4 + progress * 0.4) + ')'; ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(zone.x, zone.y);
        ctx.arc(zone.x, zone.y, zone.radius, (zone.angle || 0) - halfCone, (zone.angle || 0) + halfCone);
        ctx.closePath(); ctx.fill(); ctx.stroke();
      } else if (zone.type.includes('telegraph') && zone.type !== 'laser_telegraph' && zone.type !== 'donut_telegraph') {
        const alpha = 0.12 + progress * 0.35;
        ctx.fillStyle = 'rgba(239,68,68,' + alpha + ')';
        ctx.strokeStyle = 'rgba(239,68,68,' + (0.4 + progress * 0.4) + ')'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        ctx.strokeStyle = 'rgba(255,255,255,' + (progress * 0.3) + ')';
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius * (1 - progress), 0, Math.PI * 2); ctx.stroke();
      } else if (zone.type === 'donut_telegraph') {
        // Ring danger zone
        const alpha = 0.1 + progress * 0.3;
        ctx.fillStyle = 'rgba(239,68,68,' + alpha + ')';
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.fill();
        // Cut out inner safe zone
        ctx.save(); ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = 'rgba(0,0,0,1)';
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.innerRadius || 130, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
        // Draw ring borders
        ctx.strokeStyle = 'rgba(239,68,68,' + (0.5 + progress * 0.5) + ')'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.stroke();
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.innerRadius || 130, 0, Math.PI * 2); ctx.stroke();
      } else if (zone.type === 'donut_safe') {
        // Safe inner zone (green outline)
        ctx.strokeStyle = 'rgba(16,185,129,' + (0.3 + progress * 0.5) + ')'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.stroke();
        ctx.fillStyle = 'rgba(16,185,129,0.05)';
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.fill();
      } else if (zone.type === 'donut_explosion') {
        ctx.save();
        ctx.fillStyle = 'rgba(255,80,40,0.6)';
        ctx.shadowColor = '#ff4444'; ctx.shadowBlur = 20;
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.fill();
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = 'rgba(0,0,0,1)';
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.innerRadius || 130, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
      } else if (zone.type === 'dive_telegraph') {
        ctx.save();
        const pulse = 0.3 + 0.3 * Math.sin(Date.now() / 100);
        ctx.strokeStyle = 'rgba(255,100,100,' + pulse + ')'; ctx.lineWidth = 3;
        ctx.setLineDash([8, 8]);
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#ef4444'; ctx.font = 'bold 18px sans-serif'; ctx.textAlign = 'center';
        ctx.fillText('\u{1F3AF}', zone.x, zone.y + 6);
        ctx.restore();
      } else if (zone.type === 'poison_follow') {
        ctx.fillStyle = 'rgba(16,185,129,0.12)';
        ctx.strokeStyle = 'rgba(16,185,129,0.5)'; ctx.lineWidth = 2;
        ctx.setLineDash([6, 6]);
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        ctx.setLineDash([]);
      } else if (zone.type === 'laser_red_telegraph') {
        // Red laser telegraph ‚Äî pulsing dashed red line
        const endX = zone.x + Math.cos(zone.angle) * zone.radius;
        const endY = zone.y + Math.sin(zone.angle) * zone.radius;
        const pulse = 0.3 + 0.4 * Math.sin(Date.now() / 150); // Fast pulse for urgency
        ctx.strokeStyle = 'rgba(239,68,68,' + (pulse * progress) + ')';
        ctx.lineWidth = (zone.lineWidth || 20) * 0.5;
        ctx.setLineDash([12, 6]);
        ctx.beginPath(); ctx.moveTo(zone.x, zone.y); ctx.lineTo(endX, endY); ctx.stroke();
        ctx.setLineDash([]);
        // Small red dot at source
        ctx.fillStyle = 'rgba(239,68,68,' + pulse + ')';
        ctx.beginPath(); ctx.arc(zone.x, zone.y, 6, 0, Math.PI * 2); ctx.fill();
      } else if (zone.type === 'laser_red') {
        // Triple red laser ‚Äî menacing crimson beams
        const endX = zone.x + Math.cos(zone.angle) * zone.radius;
        const endY = zone.y + Math.sin(zone.angle) * zone.radius;
        const lw = zone.lineWidth || 50;
        const perp = zone.angle + Math.PI / 2;
        ctx.save();
        ctx.shadowColor = '#ef4444'; ctx.shadowBlur = 25;
        // Wide outer glow (dark red)
        ctx.strokeStyle = 'rgba(239,68,68,0.15)'; ctx.lineWidth = lw + 16;
        ctx.beginPath(); ctx.moveTo(zone.x, zone.y); ctx.lineTo(endX, endY); ctx.stroke();
        // Core beam ‚Äî bright red
        ctx.strokeStyle = zone.active ? 'rgba(248,113,113,0.85)' : 'rgba(239,68,68,0.3)';
        ctx.lineWidth = lw * 0.6;
        ctx.beginPath(); ctx.moveTo(zone.x, zone.y); ctx.lineTo(endX, endY); ctx.stroke();
        // Inner hot core ‚Äî white-pink
        const flicker = 0.5 + 0.3 * Math.sin(Date.now() / 80); // Rapid flicker
        ctx.strokeStyle = 'rgba(255,200,200,' + flicker + ')';
        ctx.lineWidth = lw * 0.15;
        ctx.beginPath(); ctx.moveTo(zone.x, zone.y); ctx.lineTo(endX, endY); ctx.stroke();
        // Edge particles (scattered dots along beam)
        for (let t = 0.1; t < 1; t += 0.12) {
          const px = zone.x + (endX - zone.x) * t + (Math.random() - 0.5) * lw * 0.8;
          const py = zone.y + (endY - zone.y) * t + (Math.random() - 0.5) * lw * 0.8;
          ctx.fillStyle = 'rgba(255,120,120,' + (0.3 + Math.random() * 0.4) + ')';
          ctx.beginPath(); ctx.arc(px, py, 1.5 + Math.random() * 2, 0, Math.PI * 2); ctx.fill();
        }
        ctx.restore();
      } else if (zone.type === 'laser_telegraph') {
        const endX = zone.x + Math.cos(zone.angle) * zone.radius;
        const endY = zone.y + Math.sin(zone.angle) * zone.radius;
        ctx.strokeStyle = 'rgba(234,179,8,' + (0.2 + progress * 0.5) + ')';
        ctx.lineWidth = (zone.lineWidth || 30) * 0.6;
        ctx.setLineDash([15, 8]);
        ctx.beginPath(); ctx.moveTo(zone.x, zone.y); ctx.lineTo(endX, endY); ctx.stroke();
        ctx.setLineDash([]);
      } else if (zone.type === 'menacing_wave_telegraph') {
        // Pulsing danger zone ‚Äî boss is charging, run away!
        const pulse = 0.5 + 0.5 * Math.sin(Date.now() / 200); // Fast pulse
        const innerPulse = zone.radius * (0.3 + 0.15 * Math.sin(Date.now() / 300));
        ctx.save();
        // Outer danger ring (pulsing red)
        ctx.strokeStyle = 'rgba(239,68,68,' + (0.3 + pulse * 0.4) + ')';
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 5]);
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.stroke();
        ctx.setLineDash([]);
        // Filling inner danger area (growing with progress)
        const fillR = zone.radius * progress;
        const grad = ctx.createRadialGradient(zone.x, zone.y, 0, zone.x, zone.y, fillR);
        grad.addColorStop(0, 'rgba(239,68,68,' + (0.15 + pulse * 0.1) + ')');
        grad.addColorStop(0.7, 'rgba(249,115,22,' + (0.1 + pulse * 0.08) + ')');
        grad.addColorStop(1, 'rgba(249,115,22,0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(zone.x, zone.y, fillR, 0, Math.PI * 2); ctx.fill();
        // Inner energy buildup ‚Äî concentric pulsing rings
        for (let r = 40; r < innerPulse; r += 35) {
          ctx.strokeStyle = 'rgba(255,150,50,' + (0.15 + pulse * 0.15) + ')';
          ctx.lineWidth = 1.5;
          ctx.beginPath(); ctx.arc(zone.x, zone.y, r, 0, Math.PI * 2); ctx.stroke();
        }
        // Center glow
        const cGrad = ctx.createRadialGradient(zone.x, zone.y, 0, zone.x, zone.y, 30);
        cGrad.addColorStop(0, 'rgba(255,200,100,' + (0.4 + pulse * 0.3) + ')');
        cGrad.addColorStop(1, 'rgba(255,100,50,0)');
        ctx.fillStyle = cGrad;
        ctx.beginPath(); ctx.arc(zone.x, zone.y, 30, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
      } else if (zone.type === 'fire_wave') {
        // Expanding fire ring ‚Äî deadly if caught inside
        ctx.save();
        ctx.shadowColor = '#ef4444'; ctx.shadowBlur = 30;
        // Outer ring edge (bright fire line)
        const ringWidth = 25 + 10 * Math.sin(Date.now() / 100);
        const edgeGrad = ctx.createRadialGradient(zone.x, zone.y, Math.max(0, zone.radius - ringWidth), zone.x, zone.y, zone.radius + 5);
        edgeGrad.addColorStop(0, 'rgba(255,150,50,0)');
        edgeGrad.addColorStop(0.3, 'rgba(255,100,30,0.6)');
        edgeGrad.addColorStop(0.7, 'rgba(239,68,68,0.8)');
        edgeGrad.addColorStop(1, 'rgba(200,50,30,0.2)');
        ctx.fillStyle = edgeGrad;
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius + 5, 0, Math.PI * 2); ctx.fill();
        // Inner burning area (semi-transparent fill)
        const innerGrad = ctx.createRadialGradient(zone.x, zone.y, 0, zone.x, zone.y, zone.radius);
        innerGrad.addColorStop(0, 'rgba(255,80,30,0.25)');
        innerGrad.addColorStop(0.5, 'rgba(239,68,68,0.15)');
        innerGrad.addColorStop(1, 'rgba(249,115,22,0.3)');
        ctx.fillStyle = innerGrad;
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.fill();
        // Fire particles along the expanding edge
        const numParticles = Math.floor(zone.radius / 8);
        for (let i = 0; i < numParticles; i++) {
          const a = (i / numParticles) * Math.PI * 2 + Date.now() / 500;
          const r = zone.radius + (Math.random() - 0.5) * 20;
          const px = zone.x + Math.cos(a) * r;
          const py = zone.y + Math.sin(a) * r;
          const size = 2 + Math.random() * 3;
          ctx.fillStyle = Math.random() > 0.5 ? 'rgba(255,200,50,0.7)' : 'rgba(255,100,30,0.6)';
          ctx.beginPath(); ctx.arc(px, py, size, 0, Math.PI * 2); ctx.fill();
        }
        // Bright edge stroke
        ctx.strokeStyle = 'rgba(255,180,80,0.6)'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.stroke();
        ctx.restore();
      } else if (zone.type === 'circle_explosion') {
        ctx.save();
        ctx.fillStyle = 'rgba(255,100,50,0.7)';
        ctx.shadowColor = '#ff4444'; ctx.shadowBlur = 20;
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
      } else if (zone.type === 'laser') {
        const endX = zone.x + Math.cos(zone.angle) * zone.radius;
        const endY = zone.y + Math.sin(zone.angle) * zone.radius;
        const lw = zone.lineWidth || 60;
        const perp = zone.angle + Math.PI / 2;
        ctx.save();
        ctx.shadowColor = '#eab308'; ctx.shadowBlur = 20;
        // Multiple yellow beams with gaps (3 beams, 2 gaps)
        const beamOffsets = [-lw * 0.4, 0, lw * 0.4];
        const beamWidth = lw * 0.22;
        for (const off of beamOffsets) {
          const ox = Math.cos(perp) * off;
          const oy = Math.sin(perp) * off;
          // Outer glow
          ctx.strokeStyle = 'rgba(234,179,8,0.2)'; ctx.lineWidth = beamWidth + 8;
          ctx.beginPath(); ctx.moveTo(zone.x + ox, zone.y + oy); ctx.lineTo(endX + ox, endY + oy); ctx.stroke();
          // Core beam
          ctx.strokeStyle = zone.active ? 'rgba(250,204,21,0.9)' : 'rgba(234,179,8,0.4)';
          ctx.lineWidth = beamWidth;
          ctx.beginPath(); ctx.moveTo(zone.x + ox, zone.y + oy); ctx.lineTo(endX + ox, endY + oy); ctx.stroke();
          // White hot center
          ctx.strokeStyle = 'rgba(255,255,200,0.6)'; ctx.lineWidth = beamWidth * 0.3;
          ctx.beginPath(); ctx.moveTo(zone.x + ox, zone.y + oy); ctx.lineTo(endX + ox, endY + oy); ctx.stroke();
        }
        ctx.restore();
      } else if (zone.type === 'poison_cloud') {
        const pulse = 0.1 + 0.05 * Math.sin(Date.now() / 500);
        ctx.fillStyle = 'rgba(16,185,129,' + pulse + ')';
        ctx.strokeStyle = 'rgba(16,185,129,0.3)'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        ctx.fillStyle = 'rgba(16,185,129,0.5)'; ctx.font = '16px sans-serif'; ctx.textAlign = 'center';
        ctx.fillText('\u2620', zone.x, zone.y + 5);
      } else if (zone.type === 'debuff_ring_outline') {
        // 3 concentric colored circle outlines ‚Äî D1=olive green, D2=violet, D3=pink
        const MARK_COLORS = { 1: '139,160,42', 2: '168,85,247', 3: '236,100,164' };
        const mc = MARK_COLORS[zone.ringIndex] || '255,255,255';
        const pulse = 0.4 + 0.2 * Math.sin(Date.now() / 600 + (zone.ringIndex || 0));
        const innerR = zone.innerRadius || 0;
        ctx.save();
        // Outer ring stroke (colored)
        ctx.strokeStyle = 'rgba(' + mc + ',' + pulse + ')'; ctx.lineWidth = 2.5;
        ctx.setLineDash([12, 6]);
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.stroke();
        if (innerR > 0) {
          ctx.beginPath(); ctx.arc(zone.x, zone.y, innerR, 0, Math.PI * 2); ctx.stroke();
        }
        ctx.setLineDash([]);
        // Label: I, II, III (colored)
        const labels = { 1: 'I', 2: 'II', 3: 'III' };
        const labelR = innerR > 0 ? (innerR + zone.radius) / 2 : zone.radius * 0.5;
        ctx.fillStyle = 'rgba(' + mc + ',' + (pulse * 0.8) + ')';
        ctx.font = 'bold 20px sans-serif'; ctx.textAlign = 'center';
        ctx.fillText(labels[zone.ringIndex] || '', zone.x, zone.y - labelR + 8);
        ctx.restore();
      } else if (zone.type === 'debuff_circle_telegraph') {
        // Colored filling glow before detonation
        const MARK_COLORS = { 1: '139,160,42', 2: '168,85,247', 3: '236,100,164' };
        const mc = MARK_COLORS[zone.debuffPhase] || '255,255,255';
        const innerR = zone.innerRadius || 0;
        const pulse = 0.5 + 0.5 * Math.sin(Date.now() / 120);
        ctx.save();
        if (innerR > 0) {
          ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
          ctx.arc(zone.x, zone.y, innerR, 0, Math.PI * 2, true);
          ctx.fillStyle = 'rgba(' + mc + ',' + (0.08 + progress * 0.2 + pulse * 0.05) + ')';
          ctx.fill();
        } else {
          const grad = ctx.createRadialGradient(zone.x, zone.y, 0, zone.x, zone.y, zone.radius);
          grad.addColorStop(0, 'rgba(' + mc + ',' + (0.15 + progress * 0.25) + ')');
          grad.addColorStop(0.7, 'rgba(' + mc + ',' + (0.05 + progress * 0.15) + ')');
          grad.addColorStop(1, 'rgba(' + mc + ',0)');
          ctx.fillStyle = grad;
          ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.fill();
        }
        // Bright pulsing border (colored)
        ctx.strokeStyle = 'rgba(' + mc + ',' + (0.5 + pulse * 0.4) + ')'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.stroke();
        if (innerR > 0) {
          ctx.beginPath(); ctx.arc(zone.x, zone.y, innerR, 0, Math.PI * 2); ctx.stroke();
        }
        // Phase label (colored)
        const phaseLabels = { 1: 'MARQUE I', 2: 'MARQUE II', 3: 'MARQUE III' };
        const lr = innerR > 0 ? (innerR + zone.radius) / 2 : zone.radius * 0.5;
        ctx.fillStyle = 'rgba(' + mc + ',' + (0.6 + pulse * 0.4) + ')';
        ctx.font = 'bold 16px sans-serif'; ctx.textAlign = 'center';
        ctx.fillText(phaseLabels[zone.debuffPhase] || '', zone.x, zone.y - lr + 6);
        ctx.restore();
      } else if (zone.type === 'debuff_circle_explosion') {
        // Colored flash on detonation ‚Äî bright burst then fade
        const MARK_COLORS = { 1: '139,160,42', 2: '168,85,247', 3: '236,100,164' };
        const MARK_HEX = { 1: '#8BA02A', 2: '#A855F7', 3: '#EC64A4' };
        const mc = MARK_COLORS[zone.debuffPhase] || '255,255,255';
        const mh = MARK_HEX[zone.debuffPhase] || '#ffffff';
        const fade = zone.ttl / zone.maxTtl;
        const innerR = zone.innerRadius || 0;
        ctx.save();
        ctx.shadowColor = mh; ctx.shadowBlur = 30 * fade;
        if (innerR > 0) {
          ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
          ctx.arc(zone.x, zone.y, innerR, 0, Math.PI * 2, true);
          ctx.fillStyle = 'rgba(' + mc + ',' + (0.5 * fade) + ')';
          ctx.fill();
        } else {
          ctx.fillStyle = 'rgba(' + mc + ',' + (0.5 * fade) + ')';
          ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.fill();
        }
        // Bright colored edge
        ctx.strokeStyle = 'rgba(' + mc + ',' + (0.8 * fade) + ')'; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.stroke();
        if (innerR > 0) {
          ctx.beginPath(); ctx.arc(zone.x, zone.y, innerR, 0, Math.PI * 2); ctx.stroke();
        }
        ctx.restore();
      } else if (zone.type === 'trap') {
        ctx.fillStyle = 'rgba(245,158,11,0.2)';
        ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      } else if (zone.type === 'heal_zone') {
        // Green healing circle on the ground
        const pulse = 0.15 + 0.1 * Math.sin(Date.now() / 250);
        const fadeOut = Math.min(1, zone.ttl / 0.5); // Fade out in last 0.5s
        ctx.save();
        ctx.globalAlpha = fadeOut;
        // Outer glow
        const glowGrad = ctx.createRadialGradient(zone.x, zone.y, zone.radius * 0.5, zone.x, zone.y, zone.radius * 1.2);
        glowGrad.addColorStop(0, 'rgba(16,185,129,' + (pulse + 0.05) + ')');
        glowGrad.addColorStop(1, 'rgba(16,185,129,0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius * 1.2, 0, Math.PI * 2); ctx.fill();
        // Inner fill
        ctx.fillStyle = 'rgba(16,185,129,' + pulse + ')';
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.fill();
        // Border ring
        ctx.strokeStyle = 'rgba(16,185,129,' + (0.5 + pulse) + ')'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.stroke();
        // Cross icon in center
        ctx.fillStyle = 'rgba(16,185,129,' + (0.6 + pulse) + ')';
        ctx.font = 'bold 18px sans-serif'; ctx.textAlign = 'center';
        ctx.fillText('+', zone.x, zone.y + 7);
        // Sparkle particles
        const sparkTime = Date.now() / 1000;
        for (let i = 0; i < 4; i++) {
          const sa = sparkTime * 2 + i * Math.PI / 2;
          const sr = zone.radius * 0.6;
          const sx = zone.x + Math.cos(sa) * sr;
          const sy = zone.y + Math.sin(sa) * sr - 5;
          ctx.fillStyle = 'rgba(200,255,220,' + (0.4 + 0.3 * Math.sin(sa * 3)) + ')';
          ctx.beginPath(); ctx.arc(sx, sy, 2, 0, Math.PI * 2); ctx.fill();
        }
        ctx.restore();
      } else if (zone.type === 'player_aoe_telegraph') {
        // Player-placed AoE (like rain of arrows)
        const alpha = 0.1 + progress * 0.2;
        ctx.fillStyle = 'rgba(167,139,250,' + alpha + ')';
        ctx.strokeStyle = 'rgba(167,139,250,' + (0.3 + progress * 0.4) + ')'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      }
    }

    function drawBoss(boss) {
      ctx.save();
      const size = BOSS_SPRITE_SIZE;
      const halfSize = size / 2;

      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.beginPath(); ctx.ellipse(boss.x, boss.y + halfSize * 0.6, halfSize * 0.85, halfSize * 0.3, 0, 0, Math.PI * 2); ctx.fill();

      if (boss.enraged) {
        const pulse = 0.5 + 0.5 * Math.sin(Date.now() / 150);
        const auraR = halfSize + 20 + pulse * 10;
        const auraGrad = ctx.createRadialGradient(boss.x, boss.y, halfSize * 0.5, boss.x, boss.y, auraR);
        auraGrad.addColorStop(0, 'rgba(255,0,0,0)');
        auraGrad.addColorStop(0.6, 'rgba(255,30,0,' + (0.15 + pulse * 0.1) + ')');
        auraGrad.addColorStop(1, 'rgba(255,0,0,0)');
        ctx.fillStyle = auraGrad;
        ctx.beginPath(); ctx.arc(boss.x, boss.y, auraR, 0, Math.PI * 2); ctx.fill();
      }

      // Acceleration burst aura (yellow-orange speed lines)
      if (boss.bursting) {
        const bPulse = 0.6 + 0.4 * Math.sin(Date.now() / 80);
        const burstR = halfSize + 30;
        ctx.save();
        ctx.strokeStyle = 'rgba(245,158,11,' + bPulse + ')'; ctx.lineWidth = 3;
        // Speed lines radiating outward
        for (let i = 0; i < 8; i++) {
          const a = boss.rotation + Math.PI + (i * Math.PI / 4) + (Date.now() / 200);
          const r1 = halfSize + 5;
          const r2 = burstR + 15 * Math.sin(Date.now() / 100 + i);
          ctx.beginPath();
          ctx.moveTo(boss.x + Math.cos(a) * r1, boss.y + Math.sin(a) * r1);
          ctx.lineTo(boss.x + Math.cos(a) * r2, boss.y + Math.sin(a) * r2);
          ctx.stroke();
        }
        ctx.restore();
      }

      if (bossImgLoaded) {
        ctx.save();
        ctx.translate(boss.x, boss.y);
        ctx.rotate(boss.rotation + Math.PI / 2);
        ctx.scale(-1, 1); // Flip sprite horizontally (Manaya faces correct direction)
        if (boss.enraged) { ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 25; }
        else { ctx.shadowColor = 'rgba(155,109,255,0.3)'; ctx.shadowBlur = 12; }
        ctx.drawImage(bossImg, -halfSize, -halfSize, size, size);
        if (boss.enraged) {
          ctx.globalCompositeOperation = 'source-atop';
          ctx.fillStyle = 'rgba(255,0,0,' + (0.15 + 0.1 * Math.sin(Date.now() / 200)) + ')';
          ctx.fillRect(-halfSize, -halfSize, size, size);
          ctx.globalCompositeOperation = 'source-over';
        }
        ctx.restore();
      } else {
        const grad = ctx.createRadialGradient(boss.x, boss.y, 10, boss.x, boss.y, 50);
        if (boss.enraged) { grad.addColorStop(0, '#ff4444'); grad.addColorStop(1, '#8b0000'); }
        else { grad.addColorStop(0, '#9b6dff'); grad.addColorStop(1, '#4c1d95'); }
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(boss.x, boss.y, 50, 0, Math.PI * 2); ctx.fill();
      }

      // Facing arrow
      const a = boss.rotation;
      ctx.fillStyle = boss.enraged ? '#ff4444' : '#a78bfa'; ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.moveTo(boss.x + Math.cos(a) * (halfSize + 24), boss.y + Math.sin(a) * (halfSize + 24));
      ctx.lineTo(boss.x + Math.cos(a + 0.25) * (halfSize + 12), boss.y + Math.sin(a + 0.25) * (halfSize + 12));
      ctx.lineTo(boss.x + Math.cos(a - 0.25) * (halfSize + 12), boss.y + Math.sin(a - 0.25) * (halfSize + 12));
      ctx.closePath(); ctx.fill(); ctx.globalAlpha = 1;

      // Shield ring
      if (boss.shielded) {
        const sp = 0.7 + 0.3 * Math.sin(Date.now() / 300);
        ctx.strokeStyle = 'rgba(56,189,248,' + sp + ')'; ctx.lineWidth = 4;
        ctx.shadowColor = '#38bdf8'; ctx.shadowBlur = 15;
        ctx.beginPath(); ctx.arc(boss.x, boss.y, halfSize + 8, 0, Math.PI * 2); ctx.stroke();
        ctx.shadowBlur = 0;
      }

      // Cast bar
      if (boss.casting && boss.casting.duration > 0) {
        const pct = boss.casting.progress / boss.casting.duration;
        const cr = halfSize + 16;
        ctx.strokeStyle = 'rgba(255,136,0,0.15)'; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.arc(boss.x, boss.y, cr, 0, Math.PI * 2); ctx.stroke();
        ctx.strokeStyle = '#ff8800'; ctx.lineWidth = 4;
        ctx.shadowColor = '#ff8800'; ctx.shadowBlur = 8;
        ctx.beginPath(); ctx.arc(boss.x, boss.y, cr, -Math.PI / 2, -Math.PI / 2 + pct * Math.PI * 2); ctx.stroke();
        ctx.shadowBlur = 0;
        if (boss.casting.name) {
          ctx.fillStyle = '#ff8800'; ctx.font = 'bold 13px sans-serif'; ctx.textAlign = 'center';
          ctx.fillText(boss.casting.name, boss.x, boss.y - halfSize - 22);
        }
      }

      // Rage stacks indicator
      if (boss.rageBuff > 0) {
        ctx.fillStyle = boss.rageBuff >= 3 ? '#ff0000' : '#ff8800';
        ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center';
        ctx.fillText('\u{1F525}x' + boss.rageBuff, boss.x, boss.y + halfSize + 20);
      }

      ctx.restore();
    }

    function drawPlayer(p) {
      const isMe = p.id === myId;
      const color = CLASS_COLORS[p.class] || '#888';
      ctx.save();

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath(); ctx.ellipse(p.x, p.y + 14, 20, 8, 0, 0, Math.PI * 2); ctx.fill();

      // ‚îÄ‚îÄ DEATH ANIMATION ‚îÄ‚îÄ
      if (!p.alive) {
        const pulse = 0.4 + 0.3 * Math.sin(Date.now() / 300);

        // Faded ghost sprite (per-class)
        ctx.globalAlpha = 0.25;
        const ghostImg = (p.class === 'tank' && tankIdleLoaded) ? tankIdleImg : (playerIdleLoaded ? playerIdleImg : null);
        if (ghostImg) {
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.filter = 'grayscale(100%)';
          ctx.drawImage(ghostImg, -PLAYER_SPRITE_SIZE/2, -PLAYER_SPRITE_SIZE/2, PLAYER_SPRITE_SIZE, PLAYER_SPRITE_SIZE);
          ctx.filter = 'none';
          ctx.restore();
        } else {
          ctx.fillStyle = '#333';
          ctx.beginPath(); ctx.arc(p.x, p.y, 18, 0, Math.PI * 2); ctx.fill();
        }
        ctx.globalAlpha = 1;

        // Big red DEAD text with glow
        ctx.save();
        ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 15;
        ctx.fillStyle = 'rgba(255,50,50,' + pulse + ')';
        ctx.font = 'bold 24px sans-serif'; ctx.textAlign = 'center';
        ctx.fillText('DEAD', p.x, p.y + 8);
        ctx.restore();

        // Skull
        ctx.fillStyle = 'rgba(255,255,255,' + (pulse * 0.6) + ')';
        ctx.font = '18px sans-serif'; ctx.textAlign = 'center';
        ctx.fillText('\u2620', p.x, p.y - 18);

        // Name faded
        ctx.fillStyle = '#666'; ctx.font = '10px sans-serif';
        ctx.fillText(p.username || 'DEAD', p.x, p.y + 40);

        ctx.restore(); return;
      }

      // ‚îÄ‚îÄ ALIVE PLAYER ‚îÄ‚îÄ
      if (p.dodging) {
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        ctx.beginPath(); ctx.arc(p.x, p.y, 30, 0, Math.PI * 2); ctx.fill();
      }
      if (p.invulnerable) {
        const pulse = 0.5 + 0.5 * Math.sin(Date.now() / 150);
        ctx.strokeStyle = 'rgba(255,215,0,' + pulse + ')'; ctx.lineWidth = 3;
        ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 15;
        ctx.beginPath(); ctx.arc(p.x, p.y, 28, 0, Math.PI * 2); ctx.stroke();
        ctx.shadowBlur = 0;
      }
      if (p.blocking) {
        ctx.strokeStyle = '#38bdf8'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(p.x, p.y, 26, p.aimAngle - 0.8, p.aimAngle + 0.8); ctx.stroke();
      }

      // Determine if attacking (attack sprite for 300ms after attack)
      const lastAtk = playerAttackTimers[p.id] || 0;
      const isAttacking = (Date.now() - lastAtk) < 300;

      // Draw sprite (per-class sprites)
      let spriteImg = null;
      let isTank = p.class === 'tank';
      if (isTank) {
        if (p.blocking && tankBlockLoaded) {
          spriteImg = tankBlockImg;
        } else if (isAttacking && tankAtkLoaded) {
          spriteImg = tankAtkImg;
        } else {
          spriteImg = tankIdleLoaded ? tankIdleImg : null;
        }
      } else {
        spriteImg = isAttacking && playerAtkLoaded ? playerAtkImg : (playerIdleLoaded ? playerIdleImg : null);
      }
      if (spriteImg) {
        ctx.save();
        ctx.translate(p.x, p.y);
        // Full 360¬∞ rotation: sprite faces down by default, rotate to match aim direction
        ctx.rotate(p.aimAngle - Math.PI / 2);
        // Dodge transparency
        if (p.dodging) ctx.globalAlpha = 0.5;
        // Slightly bigger during attack for emphasis
        const sprSize = isAttacking && !p.blocking ? PLAYER_SPRITE_SIZE * 1.15 : PLAYER_SPRITE_SIZE;
        // Class color tint glow
        ctx.shadowColor = color; ctx.shadowBlur = isMe ? 10 : 5;
        ctx.drawImage(spriteImg, -sprSize/2, -sprSize/2, sprSize, sprSize);
        ctx.shadowBlur = 0;
        ctx.restore();
      } else {
        // Fallback circle if sprites not loaded
        const pg = ctx.createRadialGradient(p.x - 3, p.y - 3, 3, p.x, p.y, 18);
        pg.addColorStop(0, color); pg.addColorStop(1, color + '88');
        ctx.fillStyle = pg;
        ctx.beginPath(); ctx.arc(p.x, p.y, 18, 0, Math.PI * 2); ctx.fill();
      }

      // Self indicator ring
      if (isMe) {
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(p.x, p.y, 24, 0, Math.PI * 2); ctx.stroke();
      }

      // Aim line
      ctx.strokeStyle = isMe ? 'rgba(255,255,255,0.4)' : 'rgba(255,255,255,0.15)'; ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(p.x + Math.cos(p.aimAngle) * 20, p.y + Math.sin(p.aimAngle) * 20);
      ctx.lineTo(p.x + Math.cos(p.aimAngle) * 40, p.y + Math.sin(p.aimAngle) * 40);
      ctx.stroke();

      // Small HP bar above OTHER players
      if (!isMe) {
        const bw = 44, bh = 5, by = p.y - 32;
        ctx.fillStyle = '#111'; ctx.fillRect(p.x - bw/2, by, bw, bh);
        const hpPct = p.hp / p.maxHp;
        ctx.fillStyle = hpPct > 0.5 ? '#10b981' : hpPct > 0.25 ? '#f59e0b' : '#ef4444';
        ctx.fillRect(p.x - bw/2, by, bw * hpPct, bh);
        ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
        ctx.strokeRect(p.x - bw/2, by, bw, bh);
      }

      // Class icon + Name
      ctx.fillStyle = isMe ? '#fff' : '#bbb';
      ctx.font = (isMe ? 'bold ' : '') + '10px sans-serif'; ctx.textAlign = 'center';
      const classIcon = { tank: '\u{1F6E1}', healer: '\u{1F49A}', dps_cac: '\u2694\uFE0F', dps_range: '\u{1F3AF}' };
      const icon = classIcon[p.class] || '';
      const mainH = p.mainHunter ? HUNTER_LIST[p.mainHunter]?.name : null;
      ctx.fillText(icon + ' ' + (mainH || p.username || (isMe ? 'YOU' : p.id.substring(0, 5))), p.x, p.y + 38);

      // ‚îÄ‚îÄ Buff/Debuff icons under sprite ‚îÄ‚îÄ
      if (p.buffs && p.buffs.length > 0) {
        const BUFF_DRAW = {
          poison: { icon: '\u2620', neg: true },
          atk_up: { icon: '\u2694', neg: false },
          shield: { icon: '\u{1F6E1}', neg: false },
          speed_up: { icon: '\u26A1', neg: false },
          speed_down: { icon: '\u{1F422}', neg: true },
          invuln: { icon: '\u2728', neg: false },
          taunt: { icon: '\u{1F4E2}', neg: false },
          manaya_mark_D1: { icon: '\u2460', neg: true, color: '#8BA02A' },
          manaya_mark_D2: { icon: '\u2461', neg: true, color: '#A855F7' },
          manaya_mark_D3: { icon: '\u2462', neg: true, color: '#EC64A4' },
        };
        const buffCount = p.buffs.length;
        const bSize = 16;
        const bGap = 3;
        const totalW = buffCount * bSize + (buffCount - 1) * bGap;
        let bx = p.x - totalW / 2;
        const by = p.y + 44;
        for (const b of p.buffs) {
          const info = BUFF_DRAW[b.type] || { icon: '?', neg: true };
          const customColor = info.color; // Manaya marks have custom colors
          // Background pill
          ctx.fillStyle = customColor ? (customColor + '59') : (info.neg ? 'rgba(239,68,68,0.35)' : 'rgba(16,185,129,0.35)');
          ctx.beginPath();
          ctx.roundRect(bx - 1, by - 1, bSize + 2, bSize + 2, 3);
          ctx.fill();
          ctx.strokeStyle = customColor || (info.neg ? '#ef4444' : '#10b981');
          ctx.lineWidth = 1;
          ctx.stroke();
          // Icon (colored for marks)
          ctx.fillStyle = customColor || '#fff'; ctx.font = (customColor ? 'bold ' : '') + '10px sans-serif'; ctx.textAlign = 'center';
          ctx.fillText(info.icon, bx + bSize / 2, by + bSize - 3);
          // Stack count
          if (b.stacks > 1) {
            ctx.fillStyle = info.neg ? '#ff6666' : '#6ee7b7';
            ctx.font = 'bold 8px sans-serif';
            ctx.fillText('x' + b.stacks, bx + bSize + 1, by + 5);
          }
          bx += bSize + bGap;
        }
      }

      ctx.restore();
    }

    // ‚îÄ‚îÄ Draw Add (minion/elite) ‚îÄ‚îÄ
    function drawAdd(add) {
      ctx.save();

      const isElite = add.type === 'elite';
      const isCaster = add.type === 'caster';
      const spriteSize = ADD_SPRITE_SIZE[add.type] || 42;

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath(); ctx.ellipse(add.x, add.y + spriteSize * 0.35, spriteSize * 0.4, spriteSize * 0.15, 0, 0, Math.PI * 2); ctx.fill();

      if (addImgLoaded) {
        // Glow effect for elite/caster
        if (isElite) {
          ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 14;
        } else if (isCaster) {
          ctx.shadowColor = '#7c3aed'; ctx.shadowBlur = 12;
        } else {
          ctx.shadowColor = '#ef4444'; ctx.shadowBlur = 6;
        }

        // Draw tentacle sprite (flip based on movement direction)
        ctx.save();
        ctx.translate(add.x, add.y);
        if (add.rotation > Math.PI / 2 || add.rotation < -Math.PI / 2) {
          ctx.scale(-1, 1);
        }
        ctx.drawImage(addImg, -spriteSize / 2, -spriteSize / 2, spriteSize, spriteSize);
        ctx.restore(); // Back to global canvas transform

        ctx.shadowBlur = 0;

        // Elite crown / Caster symbol on top of sprite
        if (isElite) {
          ctx.fillStyle = '#ffd700'; ctx.font = '14px sans-serif'; ctx.textAlign = 'center';
          ctx.fillText('\u{1F451}', add.x, add.y - spriteSize / 2 - 4);
        } else if (isCaster) {
          ctx.fillStyle = '#c084fc'; ctx.font = '12px sans-serif'; ctx.textAlign = 'center';
          ctx.fillText('\u{1F52E}', add.x, add.y - spriteSize / 2 - 4);
        }
      } else {
        // Fallback: colored circle
        const grad = ctx.createRadialGradient(add.x, add.y, 3, add.x, add.y, add.radius);
        grad.addColorStop(0, add.color); grad.addColorStop(1, add.color + '66');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(add.x, add.y, add.radius, 0, Math.PI * 2); ctx.fill();
      }

      // HP bar
      const bw = spriteSize * 1.1, bh = 4, by = add.y - spriteSize / 2 - 8;
      ctx.fillStyle = '#111'; ctx.fillRect(add.x - bw/2, by, bw, bh);
      const hpPct = add.hp / add.maxHp;
      ctx.fillStyle = isElite ? '#dc2626' : isCaster ? '#7c3aed' : '#ef4444';
      ctx.fillRect(add.x - bw/2, by, bw * hpPct, bh);

      // Name
      ctx.fillStyle = '#999'; ctx.font = '9px sans-serif'; ctx.textAlign = 'center';
      ctx.fillText(add.name, add.x, add.y + spriteSize / 2 + 14);

      ctx.restore();
    }

    function drawParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.age += dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= 0.96;
        p.vy *= 0.96;
        p.alpha = Math.max(0, 1 - p.age / p.life);

        if (p.age >= p.life) {
          particles.splice(i, 1);
          continue;
        }

        ctx.save();
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * (1 - p.age / p.life * 0.5), 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    function drawAggroMeters() {
      const entries = Object.entries(gameState.aggro || {}).sort((a, b) => b[1] - a[1]);
      if (entries.length === 0) return;
      const maxAggro = Math.max(1, entries[0][1]);
      const sx = 1350, sy = 1080 - entries.length * 20;

      ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'left';
      ctx.fillStyle = '#777'; ctx.fillText('AGGRO', sx, sy - 6);

      entries.forEach(([pid, aggro], i) => {
        const player = (gameState.players || []).find(p => p.id === pid);
        const color = CLASS_COLORS[player?.class] || '#888';
        const w = 120 * (aggro / maxAggro);
        const y = sy + i * 20;
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(sx, y, 120, 14);
        ctx.fillStyle = color + 'aa'; ctx.fillRect(sx, y, w, 14);
        ctx.fillStyle = '#ddd'; ctx.font = '11px sans-serif';
        ctx.fillText((pid === myId ? '* ' : '') + formatNum(aggro), sx + 125, y + 11);
      });
    }

    function drawFloatingNumbers(dt) {
      for (let i = floatingNumbers.length - 1; i >= 0; i--) {
        const fn = floatingNumbers[i];
        fn.age += dt;
        fn.y += fn.vy * dt;
        fn.vy *= 0.95; // Slow down
        fn.alpha = Math.max(0, 1 - fn.age / fn.maxAge);

        if (fn.age >= fn.maxAge) {
          floatingNumbers.splice(i, 1);
          continue;
        }

        ctx.save();
        ctx.globalAlpha = fn.alpha;
        ctx.fillStyle = fn.color;
        ctx.font = (fn.bold ? 'bold ' : '') + fn.size + 'px sans-serif';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#000'; ctx.shadowBlur = 4;
        ctx.fillText(fn.text, fn.x, fn.y);
        ctx.restore();
      }
    }

    requestAnimationFrame(render);

    // ‚îÄ‚îÄ Log ‚îÄ‚îÄ
    function log(text, cls = '') {
      const div = document.getElementById('log');
      const entry = document.createElement('div');
      entry.className = 'log-entry ' + cls;
      entry.textContent = text;
      div.appendChild(entry);
      div.scrollTop = div.scrollHeight;
      while (div.children.length > 150) div.removeChild(div.firstChild);
    }
  </script>
</body>
</html>
